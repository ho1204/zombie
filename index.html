<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Zombie Squad Rush</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Noto+Sans+KR:wght@400;700&display=swap');

        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            background-color: #1a1a1a;
            font-family: 'Noto Sans KR', sans-serif;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            position: relative; /* 자식 요소의 absolute 기준점 */
            width: 100%;
            max-width: 600px;
            height: 100%;
            background-color: #2c3e50;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI 레이어 (점수 등) */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* 게임 조작 방해 금지 */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 5;
        }

        .header {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            text-shadow: 2px 2px 0 #000;
        }

        .score-box {
            font-family: 'Black Ops One', cursive;
            font-size: 24px;
            color: #f1c40f;
        }

        .squad-count {
            font-size: 20px;
            font-weight: bold;
            color: #3498db;
        }

        /* 메뉴 스크린 (시작/게임오버 화면) - 최상단 고정 */
        #menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto; /* 버튼 클릭 가능 */
            z-index: 20; /* 가장 위에 표시 */
            transition: opacity 0.3s;
        }

        .title {
            font-family: 'Black Ops One', cursive;
            font-size: 48px;
            color: #e74c3c;
            text-shadow: 0 0 10px rgba(231, 76, 60, 0.8);
            margin-bottom: 10px;
            text-align: center;
            line-height: 1.1;
        }

        .subtitle {
            color: #bdc3c7;
            font-size: 16px;
            margin-bottom: 40px;
            text-align: center;
            line-height: 1.5;
        }

        .btn {
            background: linear-gradient(to bottom, #e74c3c, #c0392b);
            border: none;
            padding: 15px 40px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4);
            transition: transform 0.1s;
            font-family: 'Noto Sans KR', sans-serif;
            pointer-events: auto;
        }

        .btn:active {
            transform: scale(0.95);
        }

        .hidden {
            opacity: 0;
            pointer-events: none !important;
            z-index: -1 !important; /* 숨겨질 때 뒤로 보냄 */
        }

        .tutorial {
            margin-top: 20px;
            color: #7f8c8d;
            font-size: 14px;
        }

        /* 스팀팩 효과 표시 */
        #buff-indicator {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            color: #2ecc71;
            font-family: 'Black Ops One', cursive;
            font-size: 30px;
            text-shadow: 0 0 10px #2ecc71;
            display: none;
            z-index: 4;
            animation: pulse 0.5s infinite alternate;
        }
        @keyframes pulse {
            from { transform: translateX(-50%) scale(1); }
            to { transform: translateX(-50%) scale(1.1); }
        }

        /* 모바일(S25 Ultra 등) 최적화 */
        @media (max-width: 900px) {
            html, body {
                height: 100vh;
                overflow: hidden;
            }
            body {
                align-items: flex-start;
            }
            #game-container {
                max-width: 100%;
                height: 100vh;
            }
            .header {
                padding: 12px;
            }
            .score-box {
                font-size: 20px;
            }
            .squad-count {
                font-size: 18px;
            }
            .title {
                font-size: 40px;
            }
            .btn {
                font-size: 20px;
                padding: 12px 28px;
            }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div class="ui-layer">
        <div class="header">
            <div class="score-box">SCORE: <span id="score">0</span></div>
            <div class="squad-count">SQUAD: <span id="squad">1</span></div>
        </div>
        <div id="buff-indicator">RAPID FIRE!</div>
    </div>

    <div id="menu-screen">
        <div class="title">ZOMBIE<br>SQUAD</div>
        <div class="subtitle" id="menu-subtitle">
            인류 최후의 방어선!<br>
            군인을 모아 좀비를 물리치세요.
        </div>
        <button class="btn" id="start-btn">작전 시작</button>
        <div class="tutorial">PC: 방향키 / 모바일: 터치 드래그</div>
    </div>
</div>

<script>
/**
 * 게임 설정 및 상수
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const squadEl = document.getElementById('squad');
const menuScreen = document.getElementById('menu-screen');
const startBtn = document.getElementById('start-btn');
const menuSubtitle = document.getElementById('menu-subtitle');
const buffIndicator = document.getElementById('buff-indicator');

const FPS = 60; // 60fps 기준

let gameState = 'MENU';
let frameId;
let frameCount = 0; // 전체 프레임 카운트
let score = 0;
let distance = 0;
let waveCount = 0;

let canvasWidth, canvasHeight;
function resize() {
    canvasWidth = document.getElementById('game-container').offsetWidth;
    canvasHeight = document.getElementById('game-container').offsetHeight;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
}
window.addEventListener('resize', resize);
resize();

const input = { left: false, right: false, x: 0 };
let touchStartX = 0;

document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft') input.left = true;
    if (e.key === 'ArrowRight') input.right = true;
});
document.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowLeft') input.left = false;
    if (e.key === 'ArrowRight') input.right = false;
});

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    touchStartX = e.touches[0].clientX;
    input.x = player.x;
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const touchX = e.touches[0].clientX;
    const deltaX = touchX - touchStartX;
    player.targetX = input.x + deltaX;
}, { passive: false });

/**
 * 게임 로직 헬퍼
 */

// 총알 1줄당 군인 20명
function computeBulletsPerVolleyForSquad(squadSize) {
    const squad = Math.max(1, Math.floor(squadSize));
    const visualBullets = Math.min(20, Math.floor((squad - 1) / 20) + 1);
    return visualBullets;
}

function getBulletsPerVolley() {
    if (!player) return 1;
    let baseCount = computeBulletsPerVolleyForSquad(player.squadSize);
    if (player.weaponType === 'shotgun') {
        baseCount = Math.max(1, Math.round(baseCount * 1.3)); // 샷건은 30% 증가
    }
    return baseCount;
}

// 스팀팩 + 무기 적용 연사력 계산
function getCurrentShootIntervalForCalc() {
    if (!player) return FPS / 2;
    let interval = player.shootInterval;
    if (player.weaponType === 'shotgun') interval *= 1.2; // 샷건은 20% 느림
    if (player.isStimpackActive) interval /= 2; // 스팀팩일 때 2배 연사
    return interval;
}

function getVolleysPerSecond() {
    return FPS / getCurrentShootIntervalForCalc();
}

function getShotsPerSecond() {
    return getBulletsPerVolley() * getVolleysPerSecond();
}

function getBaseZombieHp() {
    const shotsPerSecond = getShotsPerSecond();
    // 1초당 발사 데미지의 50배 기준 (난이도)
    return Math.max(10, Math.floor(shotsPerSecond * 50));
}

// 스팀팩 다음 스폰 시간 설정 (현재 시간 + 3초 대기 + 6~18초 랜덤)
function scheduleNextStimpack() {
    const minWait = 3 * FPS; // 3초
    const randomWait = (Math.random() * 12 + 6) * FPS; // 6~18초
    nextStimpackFrame = frameCount + minWait + randomWait;
}

// 무기 아이템 다음 스폰 시간 (30초 간격)
function scheduleNextWeaponItem() {
    nextWeaponItemFrame = frameCount + 30 * FPS;
}

/**
 * 그래픽 헬퍼 함수
 */
function drawSoldierSprite(ctx, x, y, scale = 1) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);

    // 그림자
    ctx.fillStyle = "rgba(0,0,0,0.3)";
    ctx.beginPath();
    ctx.ellipse(0, 5, 12, 4, 0, 0, Math.PI*2);
    ctx.fill();

    // 몸통 (군복)
    ctx.fillStyle = "#4a6b4a"; 
    ctx.beginPath();
    ctx.roundRect(-8, -10, 16, 14, 4);
    ctx.fill();

    // 조끼
    ctx.fillStyle = "#2c3e2c";
    ctx.fillRect(-8, 0, 16, 4);
    ctx.fillStyle = "#1a1a1a";
    ctx.fillRect(-6, -10, 2, 14);
    ctx.fillRect(4, -10, 2, 14);

    // 머리
    ctx.fillStyle = "#e0ac69"; 
    ctx.beginPath();
    ctx.arc(0, -14, 9, 0, Math.PI*2);
    ctx.fill();

    // 헬멧
    ctx.fillStyle = "#3e553e";
    ctx.beginPath();
    ctx.arc(0, -16, 10, Math.PI, 0); 
    ctx.bezierCurveTo(10, -16, 10, -12, 0, -12);
    ctx.bezierCurveTo(-10, -12, -10, -16, -10, -16); 
    ctx.fill();
    ctx.fillStyle = "#2c3e2c";
    ctx.fillRect(-2, -26, 4, 4);

    // 고글
    ctx.fillStyle = "#333";
    ctx.beginPath();
    ctx.roundRect(-8, -16, 16, 6, 2);
    ctx.fill();
    ctx.fillStyle = "#3498db"; 
    ctx.fillRect(-5, -15, 4, 2);
    
    // 총
    ctx.fillStyle = "#111";
    ctx.translate(8, -2);
    ctx.beginPath();
    ctx.roundRect(0, -2, 12, 4, 1); 
    ctx.fillRect(0, 2, 2, 4);
    ctx.fillRect(10, -1, 2, 2); 
    ctx.fill();

    ctx.restore();
}

function drawZombieSprite(ctx, x, y, scale = 1, isBoss = false) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);

    // 그림자
    ctx.fillStyle = "rgba(0,0,0,0.3)";
    ctx.beginPath();
    ctx.ellipse(0, 8, 14, 5, 0, 0, Math.PI*2);
    ctx.fill();

    // 몸통
    ctx.fillStyle = isBoss ? "#5e3e3e" : "#5d6d7e";
    ctx.beginPath();
    ctx.roundRect(-10, -15, 20, 25, 5);
    ctx.fill();
    
    // 옷
    ctx.fillStyle = "#2c3e50";
    ctx.beginPath();
    ctx.moveTo(-10, 5);
    ctx.lineTo(-5, -5);
    ctx.lineTo(0, 5);
    ctx.lineTo(5, -5);
    ctx.lineTo(10, 5);
    ctx.lineTo(10, 10);
    ctx.lineTo(-10, 10);
    ctx.fill();

    // 머리
    ctx.fillStyle = isBoss ? "#8e44ad" : "#aab7b8";
    ctx.beginPath();
    ctx.arc(0, -20, 12, 0, Math.PI*2);
    ctx.fill();

    // 눈
    ctx.fillStyle = "#e74c3c";
    ctx.beginPath();
    ctx.arc(-4, -20, isBoss? 3 : 2, 0, Math.PI*2);
    ctx.arc(4, -20, isBoss? 3 : 2, 0, Math.PI*2);
    ctx.fill();
    
    // 상처
    ctx.strokeStyle = "#c0392b";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-3, -15);
    ctx.lineTo(3, -15);
    ctx.stroke();

    // 팔
    ctx.fillStyle = isBoss ? "#8e44ad" : "#aab7b8";
    ctx.beginPath();
    ctx.roundRect(-14, -12, 4, 12, 2); 
    ctx.roundRect(10, -12, 4, 12, 2); 
    ctx.fill();

    ctx.restore();
}

function drawStimpackSprite(ctx, x, y) {
    ctx.save();
    ctx.translate(x, y);

    // 후광
    ctx.shadowColor = "#2ecc71";
    ctx.shadowBlur = 15;

    // 본체 (의료 가방 형태)
    ctx.fillStyle = "#ecf0f1";
    ctx.beginPath();
    ctx.roundRect(-15, -15, 30, 30, 5);
    ctx.fill();
    ctx.shadowBlur = 0; // 아이콘 내부는 깔끔하게

    // 번개(공속 증가)
    ctx.fillStyle = "#2ecc71";
    ctx.beginPath();
    ctx.moveTo(2, -8);
    ctx.lineTo(-6, 2);
    ctx.lineTo(0, 2);
    ctx.lineTo(-2, 8);
    ctx.lineTo(6, -2);
    ctx.lineTo(0, -2);
    ctx.closePath();
    ctx.fill();

    // 테두리
    ctx.strokeStyle = "#27ae60";
    ctx.lineWidth = 2;
    ctx.strokeRect(-15, -15, 30, 30);

    ctx.restore();
}

function drawWeaponItemSprite(ctx, x, y, type) {
    ctx.save();
    ctx.translate(x, y);

    ctx.shadowColor = "#f1c40f";
    ctx.shadowBlur = 12;

    // 기본 상자
    ctx.fillStyle = "#34495e";
    ctx.beginPath();
    ctx.roundRect(-18, -18, 36, 36, 6);
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.strokeStyle = "#f1c40f";
    ctx.lineWidth = 2;
    ctx.strokeRect(-18, -18, 36, 36);

    // 아이콘 문자
    ctx.fillStyle = "#f1c40f";
    ctx.font = "bold 16px 'Black Ops One'";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    const label = type === 'shotgun' ? 'SG' : 'SH';
    ctx.fillText(label, 0, 0);

    ctx.restore();
}

/**
 * 게임 엔티티 클래스
 */

class Player {
    constructor() {
        this.width = 40;
        this.height = 40;
        this.x = canvasWidth / 2;
        this.y = canvasHeight - 80;
        this.targetX = this.x;
        this.speed = 0.15;
        this.maxSpeed = 8;
        
        this.squadSize = 1;
        this.shootTimer = 0;
        this.shootInterval = FPS / 2; // 기본 0.5초
        
        // 스팀팩 상태
        this.isStimpackActive = false;
        this.stimpackEndTime = 0;

        // 무기 상태
        this.weaponType = 'default'; // default | shotgun | shuriken
    }

    update() {
        if (input.left) this.targetX -= this.maxSpeed;
        if (input.right) this.targetX += this.maxSpeed;

        const edge = this.width * (1 + Math.min(this.squadSize, 5) * 0.1) / 2;
        if (this.targetX < edge) this.targetX = edge;
        if (this.targetX > canvasWidth - edge) this.targetX = canvasWidth - edge;

        this.x += (this.targetX - this.x) * this.speed;

        // 스팀팩 체크
        if (this.isStimpackActive && frameCount >= this.stimpackEndTime) {
            this.isStimpackActive = false;
            buffIndicator.style.display = 'none';
        }

        this.shootTimer++;
        let currentInterval = this.shootInterval;
        if (this.weaponType === 'shotgun') currentInterval *= 1.2; // 샷건: 20% 느림
        if (this.isStimpackActive) currentInterval /= 2;           // 스팀팩: 2배 연사
        
        if (this.shootTimer >= currentInterval) {
            this.shoot();
            this.shootTimer = 0;
        }
    }

    shoot() {
        const effectiveSquad = Math.max(1, this.squadSize);
        const baseBulletCount = computeBulletsPerVolleyForSquad(this.squadSize);
        let bulletCount = baseBulletCount;

        // 무기별 총알 수 조정
        if (this.weaponType === 'shotgun') {
            bulletCount = Math.max(1, Math.round(baseBulletCount * 1.3));
        }

        // 기본 데미지(무기 전)
        let damagePerBullet = Math.max(1, effectiveSquad / bulletCount);

        // 무기2(표창)는 기본 데미지 30% 감소
        if (this.weaponType === 'shuriken') {
            damagePerBullet *= 0.7;
        }

        // 총알 색상 결정 (스쿼드 규모에 따라)
        let bulletColor = "#f39c12"; // 기본 (1~100)
        if (this.squadSize > 300) bulletColor = "#c0392b"; // 진한 빨강
        else if (this.squadSize > 200) bulletColor = "#e74c3c"; // 연한 빨강
        else if (this.squadSize > 100) bulletColor = "#d35400"; // 주황

        const groupId = bulletGroupIdCounter++;

        // 무기 타입별 발사 패턴
        if (this.weaponType === 'shotgun') {
            // 샷건: 전방 20도 각도로 퍼져서 나감
            const spreadRad = 20 * Math.PI / 180; // 총 20도
            const startAngle = -Math.PI / 2 - spreadRad / 2;
            const step = bulletCount > 1 ? spreadRad / (bulletCount - 1) : 0;
            const speed = 15;

            for (let i = 0; i < bulletCount; i++) {
                const angle = startAngle + step * i;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                bullets.push(new Bullet(this.x, this.y - 20, damagePerBullet, groupId, bulletColor, 'shotgun', vx, vy));
            }
        } else if (this.weaponType === 'shuriken') {
            // 표창: 직선 발사, 관통용
            const speed = 15;
            const vy = -speed;
            if (bulletCount >= 3) {
                const clusterRadius = 10;
                for (let i = 0; i < bulletCount; i++) {
                    const angle = (Math.PI * 2 / bulletCount) * i;
                    const bx = this.x + Math.cos(angle) * clusterRadius;
                    const by = this.y - 20 + Math.sin(angle) * clusterRadius;
                    bullets.push(new Bullet(bx, by, damagePerBullet, groupId, "#f1c40f", 'shuriken', 0, vy));
                }
            } else {
                for (let i = 0; i < bulletCount; i++) {
                    const spread = (i - (bulletCount - 1) / 2) * 8;
                    bullets.push(new Bullet(this.x + spread, this.y - 20, damagePerBullet, groupId, "#f1c40f", 'shuriken', 0, vy));
                }
            }
        } else {
            // 기본 무기: 기존 패턴
            if (bulletCount >= 3) {
                // 3발 이상: 원형으로 뭉쳐서 나감
                const clusterRadius = 10;
                for (let i = 0; i < bulletCount; i++) {
                    const angle = (Math.PI * 2 / bulletCount) * i;
                    const bx = this.x + Math.cos(angle) * clusterRadius;
                    const by = this.y - 20 + Math.sin(angle) * clusterRadius;
                    bullets.push(new Bullet(bx, by, damagePerBullet, groupId, bulletColor));
                }
            } else {
                // 1~2발: 가로로 퍼지게
                for (let i = 0; i < bulletCount; i++) {
                    const spread = (i - (bulletCount - 1) / 2) * 8;
                    bullets.push(new Bullet(this.x + spread, this.y - 20, damagePerBullet, groupId, bulletColor));
                }
            }
        }
    }

    activateStimpack() {
        this.isStimpackActive = true;
        this.stimpackEndTime = frameCount + (5 * FPS); // 5초 지속
        buffIndicator.style.display = 'block';
        createFloatingText("SPEED UP!", this.x, this.y - 50, "#2ecc71", "30px", 60);
    }

    setWeapon(type) {
        this.weaponType = type;
        const label = type === 'shotgun' ? 'SHOTGUN' : 'SHURIKEN';
        const color = type === 'shotgun' ? '#e67e22' : '#f1c40f';
        createFloatingText(label, this.x, this.y - 70, color, '26px', 60);
    }

    draw() {
        // 군인 수 시각화: 1~20: 1명, 21~40: 2명 ... (최대 13명)
        let drawCount = Math.floor((Math.max(1, this.squadSize) - 1) / 20) + 1;
        drawCount = Math.min(drawCount, 13);
        
        // 원형으로 뭉치기
        if (drawCount === 1) {
            drawSoldierSprite(ctx, this.x, this.y, 1.2);
        } else {
            const radius = 25; 
            for(let i = 0; i < drawCount; i++) {
                const angle = (Math.PI * 2 / drawCount) * i - (Math.PI / 2);
                const ox = Math.cos(angle) * radius * (0.5 + (i%2)*0.5);
                const oy = Math.sin(angle) * radius * 0.8;
                
                drawSoldierSprite(ctx, this.x + ox, this.y + oy, 1.0);
            }
        }

        // 숫자 표시
        if (this.squadSize > 1) {
            ctx.fillStyle = "#fff";
            ctx.font = "bold 16px 'Noto Sans KR'";
            ctx.strokeStyle = "black";
            ctx.lineWidth = 3;
            ctx.strokeText(Math.floor(this.squadSize), this.x, this.y - 50);
            ctx.fillText(Math.floor(this.squadSize), this.x, this.y - 50);
        }
    }
}

class Bullet {
    constructor(x, y, damage, groupId, color, type = 'default', vx = 0, vy = -15) {
        this.x = x;
        this.y = y;
        this.radius = type === 'shuriken' ? 6 : 3.63; // 표창은 조금 더 크게
        this.speed = 15;
        this.damage = damage; // 기본 데미지 (표창의 경우 1타 기준)
        this.groupId = groupId; 
        this.color = color; 
        this.weaponType = type; // default | shotgun | shuriken
        this.vx = vx;
        this.vy = vy;
        this.markedForDeletion = false;
        this.hitCount = 0; // 표창용: 맞춘 좀비 수
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        if (this.y < -50 || this.y > canvasHeight + 50 || this.x < -50 || this.x > canvasWidth + 50) {
            this.markedForDeletion = true;
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        if (this.weaponType === 'shuriken') {
            // 표창 모양
            ctx.fillStyle = this.color;
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 10;

            ctx.beginPath();
            ctx.moveTo(0, -this.radius);
            ctx.lineTo(this.radius, 0);
            ctx.lineTo(0, this.radius);
            ctx.lineTo(-this.radius, 0);
            ctx.closePath();
            ctx.fill();
        } else {
            // 일반 탄환
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color; 
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 10;
            ctx.fill();
        }

        ctx.restore();
    }
}

class Stimpack {
    constructor() {
        this.width = 40;
        this.height = 40;
        this.x = Math.random() * (canvasWidth - this.width * 2) + this.width;
        this.y = -50;
        this.speed = 3; 
        this.markedForDeletion = false;
    }

    update() {
        this.y += this.speed;

        // 플레이어 획득 체크
        const dist = Math.hypot(this.x - player.x, this.y - player.y);
        if (dist < 40) { // 대략적인 충돌 범위
            player.activateStimpack();
            this.markedForDeletion = true;
            createParticles(this.x, this.y, '#2ecc71');
            // 먹었으므로 다시 타이머 스케줄
            scheduleNextStimpack();
        }

        // 화면 밖으로 나가면
        if (this.y > canvasHeight + 50) {
            this.markedForDeletion = true;
            // 못 먹고 지나쳤으므로 다시 타이머 스케줄
            scheduleNextStimpack();
        }
    }

    draw() {
        drawStimpackSprite(ctx, this.x, this.y);
    }
}

class WeaponItem {
    constructor(type) {
        this.type = type; // 'shotgun' | 'shuriken'
        this.width = 40;
        this.height = 40;
        this.x = Math.random() * (canvasWidth - this.width * 2) + this.width;
        this.y = -50;
        this.speed = 3;
        this.markedForDeletion = false;
    }

    update() {
        this.y += this.speed;

        const dist = Math.hypot(this.x - player.x, this.y - player.y);
        if (dist < 40) {
            player.setWeapon(this.type);
            this.markedForDeletion = true;
            createParticles(this.x, this.y, '#f1c40f');
        }

        if (this.y > canvasHeight + 50) {
            this.markedForDeletion = true;
        }
    }

    draw() {
        drawWeaponItemSprite(ctx, this.x, this.y, this.type);
    }
}

class ZombieHorde {
    constructor(isBoss = false) {
        this.isBoss = isBoss;
        
        this.radius = isBoss ? 84 : 40; 
        this.x = Math.random() * (canvasWidth - this.radius * 2) + this.radius;
        this.y = -150;
        
        // 속도 5% 감소 적용
        const speedMultiplier = 0.95; 

        this.speed = (isBoss ? 0.26 : (0.8 + Math.random() * 0.5)) * speedMultiplier;
        this.horizontalSpeed = ((isBoss ? 0.515 : 0.3) * 1.05) * speedMultiplier;

        // 체력 계산
        let baseHp = getBaseZombieHp();
        
        // 체력 감소 로직
        let hpMultiplier = 1.0;
        if (this.isBoss) {
            hpMultiplier = 0.7;
        } else if (waveCount >= 2) {
            hpMultiplier = 0.7;
        }

        baseHp = Math.floor(baseHp * hpMultiplier * 0.95); // 전체 체력 5% 감소

        // 보스전일 때 일반 좀비 체력 절반
        if (bossMode && !this.isBoss) {
            baseHp = Math.floor(baseHp * 0.5 * 0.95);
        }

        if (this.isBoss) {
            // 보스 체력 15배
            this.hp = baseHp * 15;
            this.maxHp = this.hp;
        } else {
            zombieSpawnedCount++;
            if (zombieSpawnedCount <= 5) {
                const randHp = 30 + Math.floor(Math.random() * 31); 
                let adjustedRandHp = Math.floor(randHp * hpMultiplier * 0.95);
                if (bossMode) adjustedRandHp = Math.floor(adjustedRandHp * 0.5 * 0.95);
                
                this.hp = adjustedRandHp;
                this.maxHp = this.hp;
            } else {
                this.hp = baseHp;
                this.maxHp = this.hp;
            }
        }

        this.markedForDeletion = false;
        this.hitShake = 0; 

        // 좀비 비주얼 수 계산 (체력 100단위로 1마리씩, 최대 15마리)
        this.subZombies = [];
        
        let visualCount = 1;
        if (!this.isBoss) {
             visualCount = Math.ceil(this.hp / 100);
             visualCount = Math.max(1, Math.min(visualCount, 15));
        }

        for(let i=0; i<visualCount; i++) {
            this.subZombies.push({
                ox: (Math.random()-0.5) * this.radius * 1.5,
                oy: (Math.random()-0.5) * this.radius * 0.8,
                scale: 0.8 + Math.random() * 0.4,
                wobbleOffset: Math.random() * Math.PI * 2
            });
        }
    }
    
    takeDamage(damage) {
        this.hp -= damage;
        this.hitShake = 5; 

        if (this.hp <= 0) {
            this.markedForDeletion = true;
            return true; 
        }
        return false; 
    }

    update() {
        this.y += this.speed;
        if (this.hitShake > 0) this.hitShake--;

        if (player) {
            const dx = player.x - this.x;
            const dirX = Math.sign(dx);
            this.x += dirX * this.horizontalSpeed;
        }
        
        const dist = Math.hypot(this.x - player.x, this.y - player.y);
        if (dist < this.radius + 20) {
            gameOver();
        }

        if (this.y > canvasHeight + 100) {
            if (this.hp > 0) {
                const penalty = Math.floor(this.hp * 0.8); 
                score -= penalty;
                scoreEl.innerText = score;
                createFloatingText(`-${penalty}`, this.x, canvasHeight - 50, '#e74c3c', '40px', 40); 
            }
            if (this.isBoss) {
                gameOver();
            } else {
                this.markedForDeletion = true;
            }
        }
    }

    draw() {
        ctx.save();
        
        let shakeX = 0;
        if (this.hitShake > 0) {
            shakeX = Math.sin(this.hitShake * Math.PI) * 5;
        }
        ctx.translate(this.x + shakeX, this.y);

        if (this.isBoss) {
            ctx.fillStyle = "rgba(231, 76, 60, 0.2)";
            ctx.beginPath();
            ctx.arc(0, 0, this.radius + 10, 0, Math.PI*2);
            ctx.fill();
            
            drawZombieSprite(ctx, 0, 0, 3.5, true);
        } else {
            this.subZombies.sort((a, b) => a.oy - b.oy);
            
            this.subZombies.forEach(sub => {
                let wobble = Math.sin(Date.now() * 0.005 + sub.wobbleOffset) * 2;
                drawZombieSprite(ctx, sub.ox + wobble, sub.oy, sub.scale, false);
            });
        }

        const hpPercent = Math.max(0, this.hp / this.maxHp);
        const barWidth = this.radius * 2;
        
        ctx.fillStyle = "#333";
        ctx.fillRect(-barWidth/2, -this.radius - 20, barWidth, 10);
        ctx.fillStyle = this.isBoss ? "#8e44ad" : "#e74c3c";
        ctx.fillRect(-barWidth/2, -this.radius - 20, barWidth * hpPercent, 10);
        
        ctx.fillStyle = "#fff";
        ctx.font = "bold 20px 'Black Ops One'";
        ctx.strokeStyle = "black";
        ctx.lineWidth = 3;
        ctx.strokeText(Math.floor(this.hp), 0, -this.radius - 35);
        ctx.fillText(Math.floor(this.hp), 0, -this.radius - 35);

        ctx.restore();
    }
}

class Gate {
    constructor() {
        this.id = gateIdCounter++;
        this.width = canvasWidth / 2.5 * 0.9;  
        this.height = 60 * 0.9;               
        this.x = Math.random() * (canvasWidth - this.width);
        this.y = -100;
        this.speed = 2; 
        
        this.value = 0;
        this.hitCount = 0;

        this.markedForDeletion = false;
        
        this.color = "#3498db";
    }

    update() {
        this.y += this.speed;

        if (this.y + this.height/2 > player.y - 20 && 
            this.y - this.height/2 < player.y + 20 &&
            this.x < player.x && this.x + this.width > player.x) {
            
            addSquad(this.value);
            createFloatingText(`+${this.value}`, player.x, player.y - 100, '#2ecc71', '40px', 60); 
            this.markedForDeletion = true;
            createParticles(player.x, player.y, '#3498db');
        }

        if (this.y > canvasHeight + 50) this.markedForDeletion = true;
    }

    hit() {
        this.hitCount++;
        this.value += 1;
    }

    draw() {
        ctx.save();
        ctx.globalAlpha = 0.8;
        
        const grd = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.height);
        grd.addColorStop(0, "#2980b9");
        grd.addColorStop(1, "#3498db");
        ctx.fillStyle = grd;
        
        ctx.beginPath();
        ctx.roundRect(this.x, this.y, this.width, this.height, 10);
        ctx.fill();
        
        ctx.strokeStyle = "#85c1e9";
        ctx.lineWidth = 3;
        ctx.stroke();
        
        ctx.globalAlpha = 1.0;
        
        ctx.fillStyle = "white";
        ctx.font = "bold 32px 'Black Ops One', sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "rgba(0,0,0,0.5)";
        ctx.shadowBlur = 4;
        
        let displayVal = Math.floor(this.value);
        ctx.fillText("+" + displayVal, this.x + this.width/2, this.y + this.height/2);
        
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.size = Math.random() * 4 + 2;
        this.speedX = Math.random() * 6 - 3;
        this.speedY = Math.random() * 6 - 3;
        this.life = 1.0;
    }
    update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.life -= 0.05;
    }
    draw() {
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
    }
}

class FloatingText {
    constructor(text, x, y, color, fontSize = '24px', lifetime = 30) {
        this.text = text;
        this.x = x;
        this.y = y;
        this.color = color;
        this.fontSize = fontSize;
        this.life = lifetime;
        this.maxLife = lifetime;
        this.speedY = -1;
        this.markedForDeletion = false;
    }
    update() {
        this.y += this.speedY;
        this.life--;
        if (this.life <= 0) this.markedForDeletion = true;
    }
    draw() {
        ctx.save();
        const opacity = this.life / this.maxLife;
        ctx.globalAlpha = opacity;
        
        ctx.fillStyle = this.color;
        ctx.font = `bold ${this.fontSize} 'Black Ops One'`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "rgba(0,0,0,0.8)";
        ctx.shadowBlur = 4;
        
        ctx.fillText(this.text, this.x, this.y);
        ctx.restore();
    }
}

/**
 * 게임 로직
 */

let player;
let bullets = [];
let zombies = [];
let gates = [];
let particles = [];
let floatingTexts = []; 
let stimpacks = []; // 스팀팩 아이템 배열
let weaponItems = []; // 무기 아이템 배열

let spawnTimer = 0;
let bossMode = false;
let nextStimpackFrame = 0; // 다음 스팀팩 스폰 프레임
let firstBossEncountered = false; // 첫 보스 조우 여부
let nextWeaponItemFrame = 0; // 무기 아이템 스폰 프레임
let firstSpawnDone = false; // 첫 스폰이 숫자벽인지 여부

let normalZombieKillCount = 0;
let normalZombieSpawnCount = 1;
let bulletGroupIdCounter = 0;
let bulletGroupGateHit = {}; 
let zombieSpawnedCount = 0;
let gateIdCounter = 0;

function initGame() {
    player = new Player();
    bullets = [];
    zombies = [];
    gates = [];
    particles = [];
    floatingTexts = [];
    stimpacks = [];
    weaponItems = [];
    
    score = 0;
    waveCount = 1; // 1부터 시작
    bossMode = false;
    distance = 0;
    spawnTimer = 0;
    frameCount = 0;

    normalZombieKillCount = 0;
    normalZombieSpawnCount = 1;
    bulletGroupIdCounter = 0;
    bulletGroupGateHit = {};
    zombieSpawnedCount = 0;
    gateIdCounter = 0;
    
    // 스팀팩 타이머 초기화 (첫 보스 이후 시작)
    nextStimpackFrame = Infinity;
    firstBossEncountered = false;

    // 무기 아이템 타이머 (게임 시작 30초 후 첫 등장)
    nextWeaponItemFrame = 30 * FPS;

    // 첫 스폰은 반드시 숫자벽
    firstSpawnDone = false;

    scoreEl.innerText = score;
    squadEl.innerText = 1;
    buffIndicator.style.display = 'none';
    
    gameState = 'PLAYING';
    menuScreen.classList.add('hidden');
    animate();
}

function createParticles(x, y, color) {
    for (let i = 0; i < 5; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function createFloatingText(text, x, y, color, fontSize, lifetime) {
    floatingTexts.push(new FloatingText(text, x, y, color, fontSize, lifetime));
}

function addSquad(amount) {
    player.squadSize += amount;
    squadEl.innerText = Math.floor(player.squadSize);
    
    squadEl.style.transform = "scale(1.5)";
    squadEl.style.color = "#2ecc71";
    setTimeout(() => {
        squadEl.style.transform = "scale(1)";
        squadEl.style.color = "#3498db";
    }, 200);
}

function spawnWeaponItem() {
    const type = Math.random() < 0.5 ? 'shotgun' : 'shuriken';
    weaponItems.push(new WeaponItem(type));
}

function spawnEnemies() {
    spawnTimer++;
    
    let spawnRate = 120; 

    if (spawnTimer > spawnRate) {
        spawnTimer = 0;
        waveCount++;

        // 게임 시작 후 첫 번째 스폰은 반드시 숫자벽
        if (!firstSpawnDone) {
            gates.push(new Gate());
            firstSpawnDone = true;
            return;
        }

        if (!bossMode && waveCount % 12 === 0) {
            bossMode = true;
            zombies.push(new ZombieHorde(true)); 
            
            // 보스 등장 4초 후 스팀팩 강제 1회 등장 예약
            nextStimpackFrame = frameCount + 4 * FPS;
            firstBossEncountered = true;
            
            const warning = document.createElement('div');
            warning.innerText = "BOSS APPROACHING";
            warning.style.position = "absolute";
            warning.style.top = "20%";
            warning.style.width = "100%";
            warning.style.textAlign = "center";
            warning.style.color = "#e74c3c";
            warning.style.fontSize = "40px";
            warning.style.fontWeight = "bold";
            warning.style.fontFamily = "Black Ops One";
            warning.style.textShadow = "0 0 20px black";
            warning.style.zIndex = "5";
            document.body.appendChild(warning);
            setTimeout(() => warning.remove(), 2500);
        } else {
            const rand = Math.random();
            if (rand < 0.6) {
                for (let i = 0; i < normalZombieSpawnCount; i++) {
                    zombies.push(new ZombieHorde(false));
                }
            } else if (rand < 0.8) {
                gates.push(new Gate());
            } else {
                gates.push(new Gate());
                setTimeout(() => {
                    for (let i = 0; i < normalZombieSpawnCount; i++) {
                        zombies.push(new ZombieHorde(false));
                    }
                }, 600);
            }
        }
    }
    
    if (bossMode) {
        const bossExists = zombies.some(z => z.isBoss);
        if (!bossExists) {
            bossMode = false;
        }
    }
}

function update() {
    if (gameState !== 'PLAYING') return;

    frameCount++;
    distance += 5;
    player.update();

    // 스팀팩 스폰 체크
    if (frameCount >= nextStimpackFrame && stimpacks.length === 0 && firstBossEncountered) {
        stimpacks.push(new Stimpack());
        nextStimpackFrame = Infinity; // 아이템 사라지면 다시 세팅
    }

    // 무기 아이템 스폰 체크 (30초 간격, 1개씩)
    if (frameCount >= nextWeaponItemFrame && weaponItems.length === 0) {
        spawnWeaponItem();
        scheduleNextWeaponItem();
    }

    bullets.forEach((bullet) => {
        bullet.update();
        
        let hitZombie = false;

        for (let zombie of zombies) {
            if (zombie.markedForDeletion) continue;
            const dist = Math.hypot(bullet.x - zombie.x, bullet.y - zombie.y);
            if (dist < zombie.radius + 10) {
                hitZombie = true;

                // 표창 관통 데미지 계산
                let appliedDamage = bullet.damage;
                if (bullet.weaponType === 'shuriken') {
                    if (bullet.hitCount === 0) {
                        appliedDamage = bullet.damage;          // 1번째: 100%
                    } else if (bullet.hitCount === 1) {
                        appliedDamage = bullet.damage * 0.5;   // 2번째: 50%
                    } else if (bullet.hitCount === 2) {
                        appliedDamage = bullet.damage * 0.3;   // 3번째: 30%
                    } else {
                        appliedDamage = 0;
                    }
                }

                if (appliedDamage > 0) {
                    const isDead = zombie.takeDamage(appliedDamage);
                    createFloatingText(`-${Math.floor(appliedDamage)}`, bullet.x, bullet.y, '#f1c40f', '20px', 20);
                    createParticles(bullet.x, bullet.y - 10, '#c0392b');

                    if (isDead) {
                        if (!zombie.isBoss) {
                            normalZombieKillCount++;
                            normalZombieSpawnCount = Math.min(30, 1 + Math.floor(normalZombieKillCount / 50));
                        }

                        const gain = Math.floor(zombie.maxHp / 2);
                        score += gain;
                        scoreEl.innerText = score;
                        createFloatingText(`+${gain}점`, zombie.x, zombie.y, '#f1c40f', '24px', 40); 
                    }
                }

                bullet.hitCount++;

                // 표창이 아니거나, 표창이라도 3명 맞추면 소멸
                if (bullet.weaponType !== 'shuriken' || bullet.hitCount >= 3) {
                    bullet.markedForDeletion = true;
                }
                
                break; // 한 프레임에 한 좀비만 처리
            }
        }

        if (!hitZombie) {
            for (let gate of gates) {
                if (bullet.y < gate.y + gate.height && bullet.y > gate.y &&
                    bullet.x > gate.x && bullet.x < gate.x + gate.width) {
                    
                    createParticles(bullet.x, bullet.y, '#fff');

                    const key = `${bullet.groupId}-${gate.id}`;
                    if (!bulletGroupGateHit[key]) {
                        bulletGroupGateHit[key] = true;
                        gate.hit(); // 같은 탄막이라도 다른 숫자벽은 각각 증가
                    }
                    break;
                }
            }
        }
    });

    zombies.forEach(z => z.update());
    gates.forEach(g => g.update());
    stimpacks.forEach(s => s.update());
    weaponItems.forEach(w => w.update());
    particles.forEach(p => p.update());
    floatingTexts.forEach(t => t.update());

    bullets = bullets.filter(b => !b.markedForDeletion);
    zombies = zombies.filter(z => !z.markedForDeletion);
    gates = gates.filter(g => !g.markedForDeletion);
    stimpacks = stimpacks.filter(s => !s.markedForDeletion);
    weaponItems = weaponItems.filter(w => !w.markedForDeletion);
    particles = particles.filter(p => p.life > 0);
    floatingTexts = floatingTexts.filter(t => !t.markedForDeletion);

    spawnEnemies();
}

function drawBackground() {
    ctx.fillStyle = "#2c3e50"; 
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    
    if (Math.random() < 0.5) {
        ctx.fillStyle = "rgba(0,0,0,0.1)";
        ctx.fillRect(Math.random()*canvasWidth, Math.random()*canvasHeight, 2, 2);
    }
    
    ctx.strokeStyle = "#95a5a6";
    ctx.lineWidth = 4;
    ctx.setLineDash([66, 44]);
    ctx.lineDashOffset = -distance; 
    
    ctx.beginPath();
    ctx.moveTo(canvasWidth/2, 0);
    ctx.lineTo(canvasWidth/2, canvasHeight);
    ctx.moveTo(canvasWidth * 0.2, 0);
    ctx.lineTo(canvasWidth * 0.2, canvasHeight);
    ctx.moveTo(canvasWidth * 0.8, 0);
    ctx.lineTo(canvasWidth * 0.8, canvasHeight);
    ctx.stroke();
    ctx.setLineDash([]);
}

function draw() {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    
    drawBackground();
    
    gates.forEach(g => g.draw()); 
    stimpacks.forEach(s => s.draw());
    weaponItems.forEach(w => w.draw());
    zombies.forEach(z => z.draw());
    bullets.forEach(b => b.draw());
    particles.forEach(p => p.draw());
    player.draw();
    floatingTexts.forEach(t => t.draw()); 
}

function animate() {
    if (gameState !== 'PLAYING') return;
    
    update();
    draw();
    frameId = requestAnimationFrame(animate);
}

function gameOver() {
    gameState = 'GAMEOVER';
    cancelAnimationFrame(frameId);
    
    menuScreen.classList.remove('hidden');
    document.querySelector('.title').innerText = "MISSION FAILED";
    menuSubtitle.innerHTML = `최종 점수: <span style="color:#f1c40f">${score}</span><br>최대 병력: ${Math.floor(player.squadSize)}`;
    startBtn.innerText = "다시 도전";
}

startBtn.addEventListener('click', () => {
    initGame();
});

</script>
</body>
</html>
