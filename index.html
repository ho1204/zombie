<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Zombie Squad Rush</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;400;600;700&family=Orbitron:wght@400;700;900&family=Noto+Sans+KR:wght@400;500;700&display=swap');

        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            background: radial-gradient(ellipse at center, #1a1a1a 0%, #000000 100%);
            font-family: 'Rajdhani', sans-serif;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                repeating-linear-gradient(
                    0deg,
                    rgba(139, 69, 19, 0.03) 0px,
                    transparent 1px,
                    transparent 2px,
                    rgba(139, 69, 19, 0.03) 3px
                ),
                repeating-linear-gradient(
                    90deg,
                    rgba(139, 69, 19, 0.03) 0px,
                    transparent 1px,
                    transparent 2px,
                    rgba(139, 69, 19, 0.03) 3px
                );
            pointer-events: none;
            z-index: 0;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            height: 100%;
            background: 
                linear-gradient(180deg, rgba(20, 25, 30, 0.95) 0%, rgba(15, 18, 22, 0.98) 100%),
                url('data:image/svg+xml,<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><rect width="100" height="100" fill="%23000000"/><circle cx="50" cy="50" r="1" fill="%23333333" opacity="0.3"/></svg>');
            border: 2px solid rgba(100, 100, 100, 0.2);
            border-top: 3px solid rgba(150, 150, 150, 0.3);
            box-shadow: 
                inset 0 0 50px rgba(0, 0, 0, 0.8),
                0 0 30px rgba(0, 0, 0, 0.9),
                0 0 0 1px rgba(50, 50, 50, 0.5);
            overflow: hidden;
            z-index: 1;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI 레이어 (점수 등) */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* 게임 조작 방해 금지 */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 5;
        }

        .header {
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0.4) 100%);
            border-bottom: 2px solid rgba(200, 150, 50, 0.3);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .score-box {
            font-family: 'Orbitron', monospace;
            font-size: 18px;
            font-weight: 700;
            color: #ffaa00;
            text-shadow: 
                0 0 8px rgba(255, 170, 0, 0.8),
                0 2px 4px rgba(0, 0, 0, 0.9);
            letter-spacing: 1px;
            position: relative;
            padding-left: 25px;
        }

        .score-box::before {
            content: '●';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            color: #ff3333;
            font-size: 10px;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .squad-count {
            font-family: 'Orbitron', monospace;
            font-size: 16px;
            font-weight: 600;
            color: #00d4ff;
            text-shadow: 
                0 0 6px rgba(0, 212, 255, 0.6),
                0 2px 4px rgba(0, 0, 0, 0.9);
            letter-spacing: 1px;
            position: relative;
            padding-left: 25px;
        }

        .squad-count::before {
            content: '■';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            color: #00d4ff;
            font-size: 8px;
        }

        /* 메뉴 스크린 (시작/게임오버 화면) - 최상단 고정 */
        #menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse at center, rgba(20, 10, 5, 0.95) 0%, rgba(0, 0, 0, 0.98) 100%),
                url('data:image/svg+xml,<svg width="200" height="200" xmlns="http://www.w3.org/2000/svg"><defs><pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse"><path d="M 20 0 L 0 0 0 20" fill="none" stroke="%23333" stroke-width="0.5" opacity="0.3"/></pattern></defs><rect width="200" height="200" fill="url(%23grid)"/></svg>');
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 20;
            transition: opacity 0.3s;
            border: 2px solid rgba(150, 100, 50, 0.2);
        }

        #menu-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(100, 50, 0, 0.03) 2px,
                rgba(100, 50, 0, 0.03) 4px
            );
            pointer-events: none;
        }

        .title {
            font-family: 'Orbitron', monospace;
            font-size: 42px;
            font-weight: 900;
            color: #ff8800;
            text-shadow: 
                0 0 20px rgba(255, 136, 0, 0.8),
                0 0 40px rgba(255, 136, 0, 0.4),
                0 4px 8px rgba(0, 0, 0, 0.9);
            margin-bottom: 20px;
            text-align: center;
            line-height: 1.2;
            letter-spacing: 3px;
            text-transform: uppercase;
            position: relative;
            padding: 20px 40px;
            border: 2px solid rgba(255, 136, 0, 0.3);
            background: linear-gradient(135deg, rgba(255, 136, 0, 0.1) 0%, rgba(255, 68, 0, 0.05) 100%);
            box-shadow: 
                inset 0 0 30px rgba(255, 136, 0, 0.2),
                0 0 20px rgba(255, 136, 0, 0.3);
        }

        .title::before,
        .title::after {
            content: '▸';
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 136, 0, 0.5);
            font-size: 24px;
        }

        .title::before {
            left: 10px;
        }

        .title::after {
            right: 10px;
            transform: translateY(-50%) rotate(180deg);
        }

        .subtitle {
            color: #cccccc;
            font-size: 15px;
            font-weight: 400;
            margin-bottom: 50px;
            text-align: center;
            line-height: 1.8;
            letter-spacing: 1px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            max-width: 400px;
            padding: 0 20px;
        }

        .btn {
            background: linear-gradient(135deg, rgba(200, 100, 50, 0.9) 0%, rgba(150, 60, 30, 0.95) 100%);
            border: 2px solid rgba(255, 150, 50, 0.5);
            padding: 18px 50px;
            color: #ffffff;
            font-size: 20px;
            font-weight: 700;
            font-family: 'Rajdhani', sans-serif;
            cursor: pointer;
            box-shadow: 
                inset 0 2px 4px rgba(255, 255, 255, 0.2),
                inset 0 -2px 4px rgba(0, 0, 0, 0.5),
                0 4px 12px rgba(0, 0, 0, 0.6),
                0 0 20px rgba(255, 150, 50, 0.3);
            transition: all 0.2s;
            pointer-events: auto;
            letter-spacing: 2px;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transform: rotate(45deg);
            transition: all 0.5s;
        }

        .btn:hover {
            background: linear-gradient(135deg, rgba(220, 120, 60, 0.95) 0%, rgba(170, 70, 40, 1) 100%);
            border-color: rgba(255, 180, 70, 0.7);
            box-shadow: 
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.5),
                0 6px 16px rgba(0, 0, 0, 0.7),
                0 0 30px rgba(255, 150, 50, 0.5);
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:active {
            transform: translateY(2px);
            box-shadow: 
                inset 0 4px 8px rgba(0, 0, 0, 0.6),
                0 2px 6px rgba(0, 0, 0, 0.5);
        }

        .hidden {
            opacity: 0;
            pointer-events: none !important;
            z-index: -1 !important; /* 숨겨질 때 뒤로 보냄 */
        }

        .tutorial {
            margin-top: 30px;
            color: rgba(180, 180, 180, 0.7);
            font-size: 12px;
            font-weight: 400;
            letter-spacing: 1px;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-top: 1px solid rgba(150, 150, 150, 0.2);
            border-bottom: 1px solid rgba(150, 150, 150, 0.2);
        }

        /* 스팀팩 효과 표시 */
        #buff-indicator {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ff88;
            font-family: 'Orbitron', monospace;
            font-size: 24px;
            font-weight: 700;
            text-shadow: 
                0 0 10px rgba(0, 255, 136, 0.8),
                0 0 20px rgba(0, 255, 136, 0.5),
                0 2px 4px rgba(0, 0, 0, 0.9);
            display: none;
            z-index: 4;
            animation: pulse 0.8s infinite alternate;
            letter-spacing: 3px;
            padding: 8px 20px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.4);
            box-shadow: 
                inset 0 0 15px rgba(0, 255, 136, 0.2),
                0 0 20px rgba(0, 255, 136, 0.3);
        }
        @keyframes pulse {
            from { 
                transform: translateX(-50%) scale(1);
                opacity: 0.9;
            }
            to { 
                transform: translateX(-50%) scale(1.05);
                opacity: 1;
            }
        }

        /* 모바일(S25 Ultra 등) 최적화 */
        @media (max-width: 900px) {
            html, body {
                height: 100vh;
                overflow: hidden;
            }
            body {
                align-items: flex-start;
            }
            #game-container {
                max-width: 100%;
                height: 100vh;
            }
            .header {
                padding: 12px;
            }
            .score-box {
                font-size: 20px;
            }
            .squad-count {
                font-size: 18px;
            }
            .title {
                font-size: 40px;
            }
            .btn {
                font-size: 20px;
                padding: 12px 28px;
            }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div class="ui-layer">
        <div class="header">
            <div class="score-box">SCORE: <span id="score">0</span></div>
            <div class="squad-count">SQUAD: <span id="squad">1</span></div>
        </div>
        <div id="buff-indicator">RAPID FIRE!</div>
    </div>

    <div id="menu-screen">
        <div class="title">ZOMBIE<br>SQUAD</div>
        <div class="subtitle" id="menu-subtitle">
            인류 최후의 방어선!<br>
            군인을 모아 좀비를 물리치세요.
        </div>
        <button class="btn" id="start-btn">작전 시작</button>
        <div class="tutorial">PC: 방향키 / 모바일: 터치 드래그</div>
    </div>
</div>

<script>
/**
 * 게임 설정 및 상수
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const squadEl = document.getElementById('squad');
const menuScreen = document.getElementById('menu-screen');
const startBtn = document.getElementById('start-btn');
const menuSubtitle = document.getElementById('menu-subtitle');
const buffIndicator = document.getElementById('buff-indicator');

const FPS = 60; // 60fps 기준

let gameState = 'MENU';
let frameId;
let frameCount = 0; // 전체 프레임 카운트
let score = 0;
let distance = 0;
let waveCount = 0;

let canvasWidth, canvasHeight;
function resize() {
    canvasWidth = document.getElementById('game-container').offsetWidth;
    canvasHeight = document.getElementById('game-container').offsetHeight;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
}
window.addEventListener('resize', resize);
resize();

const input = { left: false, right: false, x: 0 };
let touchStartX = 0;

document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft') input.left = true;
    if (e.key === 'ArrowRight') input.right = true;
});
document.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowLeft') input.left = false;
    if (e.key === 'ArrowRight') input.right = false;
});

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    touchStartX = e.touches[0].clientX;
    input.x = player.x;
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const touchX = e.touches[0].clientX;
    const deltaX = touchX - touchStartX;
    player.targetX = input.x + deltaX;
}, { passive: false });

/**
 * 게임 로직 헬퍼
 */

// 총알 1줄당 군인 20명
function computeBulletsPerVolleyForSquad(squadSize) {
    const squad = Math.max(1, Math.floor(squadSize));
    const visualBullets = Math.min(20, Math.floor((squad - 1) / 20) + 1);
    return visualBullets;
}

function getBulletsPerVolley() {
    if (!player) return 1;
    let baseCount = computeBulletsPerVolleyForSquad(player.squadSize);
    if (player.weaponType === 'shotgun') {
        baseCount = Math.max(1, Math.round(baseCount * 1.3)); // 샷건은 30% 증가
    }
    return baseCount;
}

// 스팀팩 + 무기 적용 연사력 계산
function getCurrentShootIntervalForCalc() {
    if (!player) return FPS / 2;
    let interval = player.shootInterval;
    if (player.weaponType === 'shotgun') interval *= 1.0; // 샷건은 기본 속도 (10% 증가)
    if (player.isStimpackActive) interval /= 2; // 스팀팩일 때 2배 연사
    return interval;
}

function getVolleysPerSecond() {
    return FPS / getCurrentShootIntervalForCalc();
}

function getShotsPerSecond() {
    return getBulletsPerVolley() * getVolleysPerSecond();
}

function getBaseZombieHp() {
    const shotsPerSecond = getShotsPerSecond();
    // 1초당 발사 데미지의 50배 기준 (난이도)
    return Math.max(10, Math.floor(shotsPerSecond * 50));
}

// 스팀팩 다음 스폰 시간 설정 (현재 시간 + 3초 대기 + 6~18초 랜덤)
function scheduleNextStimpack() {
    const minWait = 3 * FPS; // 3초
    const randomWait = (Math.random() * 12 + 6) * FPS; // 6~18초
    nextStimpackFrame = frameCount + minWait + randomWait;
}

// 무기 아이템 다음 스폰 시간 (30초 간격)
function scheduleNextWeaponItem() {
    nextWeaponItemFrame = frameCount + 30 * FPS;
}

/**
 * 그래픽 헬퍼 함수
 */
function drawSoldierSprite(ctx, x, y, scale = 1) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);

    // 그림자 (더 현실적인 그림자)
    ctx.fillStyle = "rgba(0,0,0,0.4)";
    ctx.beginPath();
    ctx.ellipse(0, 6, 14, 5, 0, 0, Math.PI*2);
    ctx.fill();

    // 몸통 (현실적인 군복 - 올리브 드랍)
    const bodyGradient = ctx.createLinearGradient(-8, -10, -8, 4);
    bodyGradient.addColorStop(0, "#5a6b4a");
    bodyGradient.addColorStop(0.5, "#4a5b3a");
    bodyGradient.addColorStop(1, "#3a4b2a");
    ctx.fillStyle = bodyGradient;
    ctx.beginPath();
    ctx.roundRect(-9, -10, 18, 15, 3);
    ctx.fill();

    // 조끼 (방탄조끼 스타일)
    ctx.fillStyle = "#2a3a2a";
    ctx.fillRect(-9, -2, 18, 5);
    // 조끼 패치
    ctx.fillStyle = "#1a2a1a";
    ctx.fillRect(-7, -10, 3, 12);
    ctx.fillRect(4, -10, 3, 12);
    // 조끼 버클/스트랩
    ctx.fillStyle = "#3a4a3a";
    ctx.fillRect(-1, -5, 2, 8);

    // 머리 (더 사실적인 피부색)
    const skinGradient = ctx.createRadialGradient(0, -14, 0, 0, -14, 9);
    skinGradient.addColorStop(0, "#f4c2a1");
    skinGradient.addColorStop(1, "#d4a281");
    ctx.fillStyle = skinGradient;
    ctx.beginPath();
    ctx.arc(0, -14, 9, 0, Math.PI*2);
    ctx.fill();

    // 헬멧 (현실적인 전투 헬멧)
    const helmetGradient = ctx.createLinearGradient(0, -20, 0, -10);
    helmetGradient.addColorStop(0, "#6a7a6a");
    helmetGradient.addColorStop(0.5, "#5a6a5a");
    helmetGradient.addColorStop(1, "#4a5a4a");
    ctx.fillStyle = helmetGradient;
    ctx.beginPath();
    ctx.arc(0, -16, 10, Math.PI, 0); 
    ctx.bezierCurveTo(10, -16, 10, -12, 0, -12);
    ctx.bezierCurveTo(-10, -12, -10, -16, -10, -16); 
    ctx.fill();
    // 헬멧 네트 패턴
    ctx.strokeStyle = "rgba(30, 40, 30, 0.5)";
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    ctx.moveTo(-8, -14);
    ctx.lineTo(8, -14);
    ctx.moveTo(-6, -16);
    ctx.lineTo(6, -16);
    ctx.stroke();
    // 헬멧 정상부
    ctx.fillStyle = "#4a5a4a";
    ctx.fillRect(-2, -26, 4, 5);
    // 헬멧 밴드
    ctx.fillStyle = "#2a3a2a";
    ctx.fillRect(-8, -13, 16, 2);

    // 고글/마스크 (더 현실적인 스타일)
    ctx.fillStyle = "rgba(20, 20, 30, 0.9)";
    ctx.beginPath();
    ctx.roundRect(-8, -17, 16, 7, 2);
    ctx.fill();
    // 고글 렌즈
    const lensGradient = ctx.createLinearGradient(-6, -17, -6, -11);
    lensGradient.addColorStop(0, "rgba(50, 100, 150, 0.6)");
    lensGradient.addColorStop(0.5, "rgba(30, 80, 130, 0.8)");
    lensGradient.addColorStop(1, "rgba(20, 60, 110, 0.6)");
    ctx.fillStyle = lensGradient;
    ctx.fillRect(-6, -17, 5, 5);
    ctx.fillRect(1, -17, 5, 5);
    // 고글 하이라이트
    ctx.fillStyle = "rgba(150, 200, 255, 0.4)";
    ctx.fillRect(-5, -16, 3, 2);
    ctx.fillRect(2, -16, 3, 2);
    
    // 총 (더 사실적인 소총)
    ctx.save();
    ctx.translate(9, -2);
    // 총신
    const gunGradient = ctx.createLinearGradient(0, 0, 12, 0);
    gunGradient.addColorStop(0, "#2a2a2a");
    gunGradient.addColorStop(0.5, "#1a1a1a");
    gunGradient.addColorStop(1, "#0a0a0a");
    ctx.fillStyle = gunGradient;
    ctx.beginPath();
    ctx.roundRect(0, -2.5, 14, 5, 1); 
    ctx.fill();
    // 총열
    ctx.fillStyle = "#0a0a0a";
    ctx.fillRect(0, -1.5, 12, 3);
    // 개머리판
    ctx.fillStyle = "#3a3a3a";
    ctx.fillRect(0, 1.5, 3, 5);
    // 총구
    ctx.fillStyle = "#1a1a1a";
    ctx.fillRect(12, -1, 2, 2);
    // 조준경
    ctx.fillStyle = "#4a4a4a";
    ctx.fillRect(6, -3, 1, 2);
    ctx.restore();

    ctx.restore();
}

function drawZombieSprite(ctx, x, y, scale = 1, isBoss = false) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);

    // 그림자 (더 어두운 그림자)
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.beginPath();
    ctx.ellipse(0, 9, 16, 6, 0, 0, Math.PI*2);
    ctx.fill();

    // 몸통 (썩은 살색)
    const bodyColor = isBoss ? "#6a4a4a" : "#6d7d8e";
    const bodyGradient = ctx.createLinearGradient(-10, -15, -10, 10);
    bodyGradient.addColorStop(0, bodyColor);
    bodyGradient.addColorStop(0.5, isBoss ? "#5a3a3a" : "#5d6d7e");
    bodyGradient.addColorStop(1, isBoss ? "#4a2a2a" : "#4d5d6e");
    ctx.fillStyle = bodyGradient;
    ctx.beginPath();
    ctx.roundRect(-11, -15, 22, 26, 4);
    ctx.fill();
    
    // 옷 (찢어진 옷)
    ctx.fillStyle = "#2c3e50";
    ctx.beginPath();
    // 찢어진 느낌
    ctx.moveTo(-11, 5);
    ctx.lineTo(-6, -5);
    ctx.lineTo(-2, 3);
    ctx.lineTo(2, -3);
    ctx.lineTo(6, 5);
    ctx.lineTo(11, 5);
    ctx.lineTo(11, 10);
    ctx.lineTo(-11, 10);
    ctx.closePath();
    ctx.fill();
    // 옷 구멍
    ctx.fillStyle = "#1a2a3a";
    ctx.beginPath();
    ctx.arc(-3, 2, 2, 0, Math.PI * 2);
    ctx.arc(4, 1, 1.5, 0, Math.PI * 2);
    ctx.fill();

    // 머리 (썩은 피부)
    const headColor = isBoss ? "#7a5a5a" : "#8a9a9a";
    const headGradient = ctx.createRadialGradient(0, -20, 0, 0, -20, 12);
    headGradient.addColorStop(0, headColor);
    headGradient.addColorStop(0.7, isBoss ? "#6a4a4a" : "#7a8a8a");
    headGradient.addColorStop(1, isBoss ? "#5a3a3a" : "#6a7a7a");
    ctx.fillStyle = headGradient;
    ctx.beginPath();
    ctx.arc(0, -20, 12, 0, Math.PI*2);
    ctx.fill();

    // 눈 (현실적인 빨간 눈)
    ctx.fillStyle = "#ff0000";
    ctx.beginPath();
    ctx.arc(-4, -20, isBoss ? 3.5 : 2.5, 0, Math.PI*2);
    ctx.arc(4, -20, isBoss ? 3.5 : 2.5, 0, Math.PI*2);
    ctx.fill();
    // 눈 하이라이트 (광택)
    ctx.fillStyle = "rgba(255, 100, 100, 0.8)";
    ctx.beginPath();
    ctx.arc(-3.5, -20.5, 1, 0, Math.PI*2);
    ctx.arc(4.5, -20.5, 1, 0, Math.PI*2);
    ctx.fill();
    
    // 상처 (더 사실적인 상처)
    ctx.strokeStyle = "#8b0000";
    ctx.fillStyle = "#6b0000";
    ctx.lineWidth = 1.5;
    // 큰 상처
    ctx.beginPath();
    ctx.moveTo(-4, -16);
    ctx.lineTo(4, -16);
    ctx.lineTo(3, -14);
    ctx.lineTo(-3, -14);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    // 작은 상처들
    ctx.beginPath();
    ctx.moveTo(-5, -18);
    ctx.lineTo(-3, -18);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(3, -18);
    ctx.lineTo(5, -18);
    ctx.stroke();
    // 얼굴 주름
    ctx.strokeStyle = "rgba(100, 50, 50, 0.6)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-3, -22);
    ctx.lineTo(3, -22);
    ctx.moveTo(-2, -15);
    ctx.lineTo(2, -15);
    ctx.stroke();

    // 팔 (썩은 팔)
    const armColor = isBoss ? "#7a5a5a" : "#8a9a9a";
    ctx.fillStyle = armColor;
    ctx.beginPath();
    ctx.roundRect(-15, -12, 5, 13, 2); 
    ctx.roundRect(10, -12, 5, 13, 2); 
    ctx.fill();
    // 팔 근육/뼈 디테일
    ctx.strokeStyle = "rgba(100, 80, 80, 0.5)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-12, -10);
    ctx.lineTo(-12, 0);
    ctx.moveTo(12, -10);
    ctx.lineTo(12, 0);
    ctx.stroke();

    ctx.restore();
}

function drawStimpackSprite(ctx, x, y) {
    ctx.save();
    ctx.translate(x, y);

    // 후광 (현실적인 글로우)
    ctx.shadowColor = "#00ff88";
    ctx.shadowBlur = 20;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;

    // 본체 (현실적인 의료 키트)
    const kitGradient = ctx.createLinearGradient(-15, -15, -15, 15);
    kitGradient.addColorStop(0, "#f5f5f5");
    kitGradient.addColorStop(0.5, "#e8e8e8");
    kitGradient.addColorStop(1, "#d0d0d0");
    ctx.fillStyle = kitGradient;
    ctx.beginPath();
    ctx.roundRect(-16, -16, 32, 32, 4);
    ctx.fill();
    ctx.shadowBlur = 0;

    // 의료 십자 표시
    ctx.fillStyle = "#ff3333";
    // 세로선
    ctx.fillRect(-3, -12, 6, 24);
    // 가로선
    ctx.fillRect(-12, -3, 24, 6);
    
    // 키트 테두리
    ctx.strokeStyle = "#333333";
    ctx.lineWidth = 2;
    ctx.strokeRect(-16, -16, 32, 32);
    
    // 키트 클립/패스너
    ctx.fillStyle = "#666666";
    ctx.fillRect(-8, -18, 16, 3);
    ctx.fillRect(-8, 15, 16, 3);

    // 하이라이트
    ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
    ctx.fillRect(-14, -14, 28, 8);

    ctx.restore();
}

function drawWeaponItemSprite(ctx, x, y, type) {
    ctx.save();
    ctx.translate(x, y);

    // 현실적인 무기 상자
    ctx.shadowColor = type === 'shotgun' ? "#ff8800" : "#ffdd00";
    ctx.shadowBlur = 15;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;

    // 무기 상자 (금속 상자 느낌)
    const boxGradient = ctx.createLinearGradient(-18, -18, -18, 18);
    boxGradient.addColorStop(0, "#4a4a4a");
    boxGradient.addColorStop(0.3, "#3a3a3a");
    boxGradient.addColorStop(0.7, "#2a2a2a");
    boxGradient.addColorStop(1, "#1a1a1a");
    ctx.fillStyle = boxGradient;
    ctx.beginPath();
    ctx.roundRect(-19, -19, 38, 38, 5);
    ctx.fill();
    
    ctx.shadowBlur = 0;
    
    // 상자 테두리 (금속 느낌)
    const borderGradient = ctx.createLinearGradient(-18, -18, 18, 18);
    borderGradient.addColorStop(0, "#888888");
    borderGradient.addColorStop(0.5, "#555555");
    borderGradient.addColorStop(1, "#333333");
    ctx.strokeStyle = borderGradient;
    ctx.lineWidth = 3;
    ctx.strokeRect(-18, -18, 36, 36);
    
    // 내부 테두리
    ctx.strokeStyle = "#1a1a1a";
    ctx.lineWidth = 1;
    ctx.strokeRect(-15, -15, 30, 30);
    
    // 상자 하이라이트
    ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
    ctx.fillRect(-17, -17, 34, 12);
    
    // 무기 라벨 (더 현실적인 스타일)
    ctx.fillStyle = type === 'shotgun' ? "#ff8800" : "#ffdd00";
    ctx.font = "bold 12px 'Rajdhani'";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.shadowColor = "rgba(0, 0, 0, 0.8)";
    ctx.shadowBlur = 4;
    const label = type === 'shotgun' ? '샷건' : '표창';
    ctx.fillText(label, 0, 0);
    ctx.shadowBlur = 0;

    ctx.restore();
}

/**
 * 게임 엔티티 클래스
 */

class Player {
    constructor() {
        this.width = 40;
        this.height = 40;
        this.x = canvasWidth / 2;
        this.y = canvasHeight - 80;
        this.targetX = this.x;
        this.speed = 0.15;
        this.maxSpeed = 8;
        
        this.squadSize = 1;
        this.shootTimer = 0;
        this.shootInterval = FPS / 2; // 기본 0.5초
        
        // 스팀팩 상태
        this.isStimpackActive = false;
        this.stimpackEndTime = 0;

        // 무기 상태
        this.weaponType = 'default'; // default | shotgun | shuriken
    }

    update() {
        if (input.left) this.targetX -= this.maxSpeed;
        if (input.right) this.targetX += this.maxSpeed;

        const edge = this.width * (1 + Math.min(this.squadSize, 5) * 0.1) / 2;
        if (this.targetX < edge) this.targetX = edge;
        if (this.targetX > canvasWidth - edge) this.targetX = canvasWidth - edge;

        this.x += (this.targetX - this.x) * this.speed;

        // 스팀팩 체크
        if (this.isStimpackActive && frameCount >= this.stimpackEndTime) {
            this.isStimpackActive = false;
            buffIndicator.style.display = 'none';
        }

        this.shootTimer++;
        let currentInterval = this.shootInterval;
        if (this.weaponType === 'shotgun') currentInterval *= 1.0; // 샷건: 기본 속도 (10% 증가)
        if (this.isStimpackActive) currentInterval /= 2;           // 스팀팩: 2배 연사
        
        if (this.shootTimer >= currentInterval) {
            this.shoot();
            this.shootTimer = 0;
        }
    }

    shoot() {
        const effectiveSquad = Math.max(1, this.squadSize);
        const baseBulletCount = computeBulletsPerVolleyForSquad(this.squadSize);
        let bulletCount = baseBulletCount;

        // 무기별 총알 수 조정
        if (this.weaponType === 'shotgun') {
            bulletCount = Math.max(1, Math.round(baseBulletCount * 1.3));
        }

        // 기본 데미지(무기 전)
        let damagePerBullet = Math.max(1, effectiveSquad / bulletCount);

        // 무기2(표창)는 기본 데미지 30% 감소
        if (this.weaponType === 'shuriken') {
            damagePerBullet *= 0.7;
        }

        // 총알 색상 결정 (스쿼드 규모에 따라)
        let bulletColor = "#f39c12"; // 기본 (1~100)
        if (this.squadSize > 300) bulletColor = "#c0392b"; // 진한 빨강
        else if (this.squadSize > 200) bulletColor = "#e74c3c"; // 연한 빨강
        else if (this.squadSize > 100) bulletColor = "#d35400"; // 주황

        const groupId = bulletGroupIdCounter++;

        // 무기 타입별 발사 패턴
        if (this.weaponType === 'shotgun') {
            // 샷건: 전방 20도 각도로 퍼져서 나감
            const spreadRad = 20 * Math.PI / 180; // 총 20도
            const startAngle = -Math.PI / 2 - spreadRad / 2;
            const step = bulletCount > 1 ? spreadRad / (bulletCount - 1) : 0;
            const speed = 15;

            for (let i = 0; i < bulletCount; i++) {
                const angle = startAngle + step * i;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                bullets.push(new Bullet(this.x, this.y - 20, damagePerBullet, groupId, bulletColor, 'shotgun', vx, vy));
            }
        } else if (this.weaponType === 'shuriken') {
            // 표창: 직선 발사, 관통용
            const speed = 15;
            const vy = -speed;
            if (bulletCount >= 3) {
                const clusterRadius = 10;
                for (let i = 0; i < bulletCount; i++) {
                    const angle = (Math.PI * 2 / bulletCount) * i;
                    const bx = this.x + Math.cos(angle) * clusterRadius;
                    const by = this.y - 20 + Math.sin(angle) * clusterRadius;
                    bullets.push(new Bullet(bx, by, damagePerBullet, groupId, "#f1c40f", 'shuriken', 0, vy));
                }
            } else {
                for (let i = 0; i < bulletCount; i++) {
                    const spread = (i - (bulletCount - 1) / 2) * 8;
                    bullets.push(new Bullet(this.x + spread, this.y - 20, damagePerBullet, groupId, "#f1c40f", 'shuriken', 0, vy));
                }
            }
        } else {
            // 기본 무기: 기존 패턴
            if (bulletCount >= 3) {
                // 3발 이상: 원형으로 뭉쳐서 나감
                const clusterRadius = 10;
                for (let i = 0; i < bulletCount; i++) {
                    const angle = (Math.PI * 2 / bulletCount) * i;
                    const bx = this.x + Math.cos(angle) * clusterRadius;
                    const by = this.y - 20 + Math.sin(angle) * clusterRadius;
                    bullets.push(new Bullet(bx, by, damagePerBullet, groupId, bulletColor));
                }
            } else {
                // 1~2발: 가로로 퍼지게
                for (let i = 0; i < bulletCount; i++) {
                    const spread = (i - (bulletCount - 1) / 2) * 8;
                    bullets.push(new Bullet(this.x + spread, this.y - 20, damagePerBullet, groupId, bulletColor));
                }
            }
        }
    }

    activateStimpack() {
        this.isStimpackActive = true;
        this.stimpackEndTime = frameCount + (5 * FPS); // 5초 지속
        buffIndicator.style.display = 'block';
        createFloatingText("SPEED UP!", this.x, this.y - 50, "#2ecc71", "30px", 60);
    }

    setWeapon(type) {
        this.weaponType = type;
        const label = type === 'shotgun' ? '샷건' : '표창';
        const color = type === 'shotgun' ? '#e67e22' : '#f1c40f';
        createFloatingText(label, this.x, this.y - 70, color, '26px', 60);
    }

    draw() {
        // 군인 수 시각화: 1~20: 1명, 21~40: 2명 ... (최대 13명)
        let drawCount = Math.floor((Math.max(1, this.squadSize) - 1) / 20) + 1;
        drawCount = Math.min(drawCount, 13);
        
        // 원형으로 뭉치기
        if (drawCount === 1) {
            drawSoldierSprite(ctx, this.x, this.y, 1.2);
        } else {
            const radius = 25; 
            for(let i = 0; i < drawCount; i++) {
                const angle = (Math.PI * 2 / drawCount) * i - (Math.PI / 2);
                const ox = Math.cos(angle) * radius * (0.5 + (i%2)*0.5);
                const oy = Math.sin(angle) * radius * 0.8;
                
                drawSoldierSprite(ctx, this.x + ox, this.y + oy, 1.0);
            }
        }

        // 숫자 표시 (현실적인 HUD 스타일)
        if (this.squadSize > 1) {
            ctx.fillStyle = "#ffffff";
            ctx.font = "bold 18px 'Orbitron'";
            ctx.strokeStyle = "rgba(0,0,0,0.9)";
            ctx.lineWidth = 5;
            ctx.strokeText(Math.floor(this.squadSize), this.x, this.y - 50);
            
            // 숫자 그라데이션
            const numGradient = ctx.createLinearGradient(this.x - 15, this.y - 55, this.x + 15, this.y - 45);
            numGradient.addColorStop(0, "#ffffff");
            numGradient.addColorStop(0.5, "#88ccff");
            numGradient.addColorStop(1, "#ffffff");
            ctx.fillStyle = numGradient;
            ctx.fillText(Math.floor(this.squadSize), this.x, this.y - 50);
        }
    }
}

class Bullet {
    constructor(x, y, damage, groupId, color, type = 'default', vx = 0, vy = -15) {
        this.x = x;
        this.y = y;
        this.radius = type === 'shuriken' ? 6 : 3.63; // 표창은 조금 더 크게
        this.speed = 15;
        this.damage = damage; // 기본 데미지 (표창의 경우 1타 기준)
        this.groupId = groupId; 
        this.color = color; 
        this.weaponType = type; // default | shotgun | shuriken
        this.vx = vx;
        this.vy = vy;
        this.markedForDeletion = false;
        this.hitCount = 0; // 표창용: 맞춘 좀비 수
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        if (this.y < -50 || this.y > canvasHeight + 50 || this.x < -50 || this.x > canvasWidth + 50) {
            this.markedForDeletion = true;
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        if (this.weaponType === 'shuriken') {
            // 표창 모양 - 4면 날카로운 디자인
            ctx.save();
            
            // 회전 애니메이션 (날카로움 표현)
            const rotation = (Date.now() * 0.01) % (Math.PI * 2);
            ctx.rotate(rotation);
            
            // 외부 그라데이션 효과
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 1.5);
            gradient.addColorStop(0, this.color);
            gradient.addColorStop(0.7, this.color);
            gradient.addColorStop(1, 'rgba(241, 196, 15, 0.3)');
            
            // 그림자 효과
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 12;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            
            // 메인 표창 본체 (4면 날카로운 모양)
            ctx.beginPath();
            const r = this.radius;
            // 상단 날카로운 끝
            ctx.moveTo(0, -r);
            // 우상단 날
            ctx.lineTo(r * 0.7, -r * 0.3);
            // 우측 날카로운 끝
            ctx.lineTo(r, 0);
            // 우하단 날
            ctx.lineTo(r * 0.3, r * 0.7);
            // 하단 날카로운 끝
            ctx.lineTo(0, r);
            // 좌하단 날
            ctx.lineTo(-r * 0.3, r * 0.7);
            // 좌측 날카로운 끝
            ctx.lineTo(-r, 0);
            // 좌상단 날
            ctx.lineTo(-r * 0.7, -r * 0.3);
            ctx.closePath();
            
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // 내부 하이라이트 (금속질 느낌)
            ctx.shadowBlur = 0;
            ctx.beginPath();
            const innerR = r * 0.6;
            ctx.moveTo(0, -innerR);
            ctx.lineTo(innerR * 0.7, -innerR * 0.3);
            ctx.lineTo(innerR, 0);
            ctx.lineTo(innerR * 0.3, innerR * 0.7);
            ctx.lineTo(0, innerR);
            ctx.lineTo(-innerR * 0.3, innerR * 0.7);
            ctx.lineTo(-innerR, 0);
            ctx.lineTo(-innerR * 0.7, -innerR * 0.3);
            ctx.closePath();
            
            const innerGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, innerR);
            innerGradient.addColorStop(0, '#fff9c4');
            innerGradient.addColorStop(0.5, this.color);
            innerGradient.addColorStop(1, 'rgba(241, 196, 15, 0.6)');
            ctx.fillStyle = innerGradient;
            ctx.fill();
            
            // 날카로운 가장자리 강조
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            
            // 중심 홀 (표창 특유의 구멍)
            ctx.beginPath();
            ctx.arc(0, 0, r * 0.15, 0, Math.PI * 2);
            ctx.fillStyle = '#2c3e50';
            ctx.fill();
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 0.5;
            ctx.stroke();
            
            // 가장 날카로운 부분 강조 (4면 끝부분)
            ctx.fillStyle = '#fff';
            ctx.globalAlpha = 0.8;
            const tipR = r * 0.9;
            const tipSize = 2;
            // 상단 끝
            ctx.fillRect(-tipSize/2, -tipR, tipSize, tipSize * 2);
            // 우측 끝
            ctx.fillRect(tipR - tipSize, -tipSize/2, tipSize * 2, tipSize);
            // 하단 끝
            ctx.fillRect(-tipSize/2, tipR - tipSize * 2, tipSize, tipSize * 2);
            // 좌측 끝
            ctx.fillRect(-tipR, -tipSize/2, tipSize * 2, tipSize);
            
            ctx.globalAlpha = 1.0;
            ctx.restore();
        } else {
            // 일반 탄환 (현실적인 총알)
            // 총알 본체
            const bulletGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
            bulletGradient.addColorStop(0, this.color);
            bulletGradient.addColorStop(0.7, this.color);
            bulletGradient.addColorStop(1, "rgba(0,0,0,0.8)");
            
            ctx.fillStyle = bulletGradient;
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // 총알 하이라이트
            ctx.shadowBlur = 0;
            ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
            ctx.beginPath();
            ctx.arc(-this.radius * 0.3, -this.radius * 0.3, this.radius * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            // 총알 외곽선
            ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        ctx.restore();
    }
}

class Stimpack {
    constructor() {
        this.width = 40;
        this.height = 40;
        this.x = Math.random() * (canvasWidth - this.width * 2) + this.width;
        this.y = -50;
        this.speed = 3; 
        this.markedForDeletion = false;
    }

    update() {
        this.y += this.speed;

        // 플레이어 획득 체크
        const dist = Math.hypot(this.x - player.x, this.y - player.y);
        if (dist < 40) { // 대략적인 충돌 범위
            player.activateStimpack();
            this.markedForDeletion = true;
            createParticles(this.x, this.y, '#2ecc71');
            // 먹었으므로 다시 타이머 스케줄
            scheduleNextStimpack();
        }

        // 화면 밖으로 나가면
        if (this.y > canvasHeight + 50) {
            this.markedForDeletion = true;
            // 못 먹고 지나쳤으므로 다시 타이머 스케줄
            scheduleNextStimpack();
        }
    }

    draw() {
        drawStimpackSprite(ctx, this.x, this.y);
    }
}

class WeaponItem {
    constructor(type) {
        this.type = type; // 'shotgun' | 'shuriken'
        this.width = 40;
        this.height = 40;
        this.x = Math.random() * (canvasWidth - this.width * 2) + this.width;
        this.y = -50;
        this.speed = 3;
        this.markedForDeletion = false;
    }

    update() {
        this.y += this.speed;

        const dist = Math.hypot(this.x - player.x, this.y - player.y);
        if (dist < 40) {
            player.setWeapon(this.type);
            this.markedForDeletion = true;
            createParticles(this.x, this.y, '#f1c40f');
        }

        if (this.y > canvasHeight + 50) {
            this.markedForDeletion = true;
        }
    }

    draw() {
        drawWeaponItemSprite(ctx, this.x, this.y, this.type);
    }
}

class ZombieHorde {
    constructor(isBoss = false) {
        this.isBoss = isBoss;
        
        this.radius = isBoss ? 84 : 40; 
        this.x = Math.random() * (canvasWidth - this.radius * 2) + this.radius;
        this.y = -150;
        
        // 속도 5% 감소 적용
        const speedMultiplier = 0.95; 

        this.speed = (isBoss ? 0.26 : (0.8 + Math.random() * 0.5)) * speedMultiplier;
        this.horizontalSpeed = ((isBoss ? 0.515 : 0.3) * 1.05) * speedMultiplier;

        // 체력 계산
        let baseHp = getBaseZombieHp();
        
        // 체력 감소 로직
        let hpMultiplier = 1.0;
        if (this.isBoss) {
            hpMultiplier = 0.7;
        } else if (waveCount >= 2) {
            hpMultiplier = 0.7;
        }

        baseHp = Math.floor(baseHp * hpMultiplier * 0.95); // 전체 체력 5% 감소

        // 보스전일 때 일반 좀비 체력 절반
        if (bossMode && !this.isBoss) {
            baseHp = Math.floor(baseHp * 0.5 * 0.95);
        }

        if (this.isBoss) {
            // 보스 체력 15배 (5% 감소: 14.25배)
            this.hp = baseHp * 14.25;
            this.maxHp = this.hp;
        } else {
            zombieSpawnedCount++;
            if (zombieSpawnedCount <= 5) {
                const randHp = 30 + Math.floor(Math.random() * 31); 
                let adjustedRandHp = Math.floor(randHp * hpMultiplier * 0.95);
                if (bossMode) adjustedRandHp = Math.floor(adjustedRandHp * 0.5 * 0.95);
                
                this.hp = adjustedRandHp;
                this.maxHp = this.hp;
            } else {
                this.hp = baseHp;
                this.maxHp = this.hp;
            }
        }

        this.markedForDeletion = false;
        this.hitShake = 0; 

        // 좀비 비주얼 수 계산 (체력 100단위로 1마리씩, 최대 15마리)
        this.subZombies = [];
        
        let visualCount = 1;
        if (!this.isBoss) {
             visualCount = Math.ceil(this.hp / 100);
             visualCount = Math.max(1, Math.min(visualCount, 15));
        }

        for(let i=0; i<visualCount; i++) {
            this.subZombies.push({
                ox: (Math.random()-0.5) * this.radius * 1.5,
                oy: (Math.random()-0.5) * this.radius * 0.8,
                scale: 0.8 + Math.random() * 0.4,
                wobbleOffset: Math.random() * Math.PI * 2
            });
        }
    }
    
    takeDamage(damage) {
        this.hp -= damage;
        this.hitShake = 5; 

        if (this.hp <= 0) {
            this.markedForDeletion = true;
            return true; 
        }
        return false; 
    }

    update() {
        this.y += this.speed;
        if (this.hitShake > 0) this.hitShake--;

        if (player) {
            const dx = player.x - this.x;
            const dirX = Math.sign(dx);
            this.x += dirX * this.horizontalSpeed;
        }
        
        const dist = Math.hypot(this.x - player.x, this.y - player.y);
        if (dist < this.radius + 20) {
            gameOver();
        }

        if (this.y > canvasHeight + 100) {
            if (this.hp > 0) {
                const penalty = Math.floor(this.hp * 0.8); 
                score -= penalty;
                scoreEl.innerText = score;
                createFloatingText(`-${penalty}`, this.x, canvasHeight - 50, '#e74c3c', '40px', 40); 
            }
            if (this.isBoss) {
                gameOver();
            } else {
                this.markedForDeletion = true;
            }
        }
    }

    draw() {
        ctx.save();
        
        let shakeX = 0;
        if (this.hitShake > 0) {
            shakeX = Math.sin(this.hitShake * Math.PI) * 5;
        }
        ctx.translate(this.x + shakeX, this.y);

        if (this.isBoss) {
            // 보스 후광 (더 현실적인 위협감)
            const bossGlow = ctx.createRadialGradient(0, 0, this.radius, 0, 0, this.radius + 20);
            bossGlow.addColorStop(0, "rgba(200, 0, 0, 0.4)");
            bossGlow.addColorStop(0.5, "rgba(150, 0, 0, 0.2)");
            bossGlow.addColorStop(1, "rgba(100, 0, 0, 0)");
            ctx.fillStyle = bossGlow;
            ctx.beginPath();
            ctx.arc(0, 0, this.radius + 20, 0, Math.PI*2);
            ctx.fill();
            
            // 보스 맥동 효과
            const pulse = Math.sin(Date.now() * 0.005) * 0.1 + 0.9;
            ctx.fillStyle = "rgba(255, 0, 0, 0.15)";
            ctx.beginPath();
            ctx.arc(0, 0, (this.radius + 15) * pulse, 0, Math.PI*2);
            ctx.fill();
            
            drawZombieSprite(ctx, 0, 0, 3.5, true);
        } else {
            this.subZombies.sort((a, b) => a.oy - b.oy);
            
            this.subZombies.forEach(sub => {
                let wobble = Math.sin(Date.now() * 0.005 + sub.wobbleOffset) * 2;
                drawZombieSprite(ctx, sub.ox + wobble, sub.oy, sub.scale, false);
            });
        }

        const hpPercent = Math.max(0, this.hp / this.maxHp);
        const barWidth = this.radius * 2;
        
        // HP 바 배경 (현실적인 금속 프레임)
        const barBgGradient = ctx.createLinearGradient(-barWidth/2, -this.radius - 20, -barWidth/2, -this.radius - 10);
        barBgGradient.addColorStop(0, "#1a1a1a");
        barBgGradient.addColorStop(0.5, "#0a0a0a");
        barBgGradient.addColorStop(1, "#1a1a1a");
        ctx.fillStyle = barBgGradient;
        ctx.fillRect(-barWidth/2 - 2, -this.radius - 22, barWidth + 4, 14);
        
        // HP 바 내부 배경
        ctx.fillStyle = "rgba(20, 20, 20, 0.9)";
        ctx.fillRect(-barWidth/2, -this.radius - 20, barWidth, 10);
        
        // HP 바 (현실적인 그라데이션)
        const hpBarGradient = ctx.createLinearGradient(-barWidth/2, -this.radius - 20, -barWidth/2 + barWidth * hpPercent, -this.radius - 10);
        if (this.isBoss) {
            hpBarGradient.addColorStop(0, "#aa44cc");
            hpBarGradient.addColorStop(1, "#8e22aa");
        } else {
            hpBarGradient.addColorStop(0, "#ff4444");
            hpBarGradient.addColorStop(1, "#cc2222");
        }
        ctx.fillStyle = hpBarGradient;
        ctx.fillRect(-barWidth/2, -this.radius - 20, barWidth * hpPercent, 10);
        
        // HP 바 하이라이트
        if (hpPercent > 0) {
            ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
            ctx.fillRect(-barWidth/2, -this.radius - 20, barWidth * hpPercent, 3);
        }
        
        // HP 바 테두리
        ctx.strokeStyle = "#555555";
        ctx.lineWidth = 2;
        ctx.strokeRect(-barWidth/2 - 2, -this.radius - 22, barWidth + 4, 14);
        ctx.strokeStyle = "#888888";
        ctx.lineWidth = 1;
        ctx.strokeRect(-barWidth/2 - 1, -this.radius - 21, barWidth + 2, 12);
        
        ctx.fillStyle = "#ffffff";
        ctx.font = "bold 18px 'Orbitron'";
        ctx.strokeStyle = "rgba(0,0,0,0.9)";
        ctx.lineWidth = 4;
        ctx.strokeText(Math.floor(this.hp), 0, -this.radius - 35);
        ctx.fillText(Math.floor(this.hp), 0, -this.radius - 35);

        ctx.restore();
    }
}

class Gate {
    constructor() {
        this.id = gateIdCounter++;
        this.width = canvasWidth / 2.5 * 0.9;  
        this.height = 60 * 0.9;               
        this.x = Math.random() * (canvasWidth - this.width);
        this.y = -100;
        this.speed = 2; 
        
        this.value = 0;
        this.hitCount = 0;

        this.markedForDeletion = false;
        
        this.color = "#3498db";
    }

    update() {
        this.y += this.speed;

        if (this.y + this.height/2 > player.y - 20 && 
            this.y - this.height/2 < player.y + 20 &&
            this.x < player.x && this.x + this.width > player.x) {
            
            addSquad(this.value);
            createFloatingText(`+${this.value}`, player.x, player.y - 100, '#2ecc71', '40px', 60); 
            this.markedForDeletion = true;
            createParticles(player.x, player.y, '#3498db');
        }

        if (this.y > canvasHeight + 50) this.markedForDeletion = true;
    }

    hit() {
        this.hitCount++;
        this.value += 1;
    }

    draw() {
        ctx.save();
        ctx.globalAlpha = 0.95;
        
        // 현실적인 게이트 디자인 (금속 느낌)
        const grd = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.height);
        grd.addColorStop(0, "#4a6a8a");
        grd.addColorStop(0.3, "#3a5a7a");
        grd.addColorStop(0.7, "#2a4a6a");
        grd.addColorStop(1, "#1a3a5a");
        ctx.fillStyle = grd;
        
        ctx.beginPath();
        ctx.roundRect(this.x, this.y, this.width, this.height, 6);
        ctx.fill();
        
        // 게이트 테두리 (금속 느낌)
        const borderGradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y);
        borderGradient.addColorStop(0, "#8a9aab");
        borderGradient.addColorStop(0.5, "#5a6a7a");
        borderGradient.addColorStop(1, "#8a9aab");
        ctx.strokeStyle = borderGradient;
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // 게이트 내부 테두리
        ctx.strokeStyle = "#2a3a4a";
        ctx.lineWidth = 1;
        ctx.strokeRect(this.x + 3, this.y + 3, this.width - 6, this.height - 6);
        
        // 게이트 하이라이트
        ctx.fillStyle = "rgba(255, 255, 255, 0.15)";
        ctx.fillRect(this.x, this.y, this.width, this.height * 0.3);
        
        // 게이트 패널 라인
        ctx.strokeStyle = "rgba(100, 120, 140, 0.4)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(this.x + this.width * 0.33, this.y);
        ctx.lineTo(this.x + this.width * 0.33, this.y + this.height);
        ctx.moveTo(this.x + this.width * 0.67, this.y);
        ctx.lineTo(this.x + this.width * 0.67, this.y + this.height);
        ctx.stroke();
        
        ctx.globalAlpha = 1.0;
        
        // 숫자 텍스트 (더 현실적인 스타일)
        ctx.fillStyle = "#ffffff";
        ctx.font = "900 32px 'Orbitron', sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "rgba(0,0,0,0.9)";
        ctx.shadowBlur = 8;
        
        let displayVal = Math.floor(this.value);
        ctx.strokeStyle = "rgba(0,0,0,0.9)";
        ctx.lineWidth = 4;
        ctx.strokeText("+" + displayVal, this.x + this.width/2, this.y + this.height/2);
        
        // 숫자 그라데이션 효과
        const textGradient = ctx.createLinearGradient(
            this.x + this.width/2 - 30, this.y + this.height/2,
            this.x + this.width/2 + 30, this.y + this.height/2
        );
        textGradient.addColorStop(0, "#ffffff");
        textGradient.addColorStop(0.5, "#ffff88");
        textGradient.addColorStop(1, "#ffffff");
        ctx.fillStyle = textGradient;
        ctx.fillText("+" + displayVal, this.x + this.width/2, this.y + this.height/2);
        
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.size = Math.random() * 4 + 2;
        this.speedX = Math.random() * 6 - 3;
        this.speedY = Math.random() * 6 - 3;
        this.life = 1.0;
    }
    update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.life -= 0.05;
    }
    draw() {
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
    }
}

class FloatingText {
    constructor(text, x, y, color, fontSize = '24px', lifetime = 30) {
        this.text = text;
        this.x = x;
        this.y = y;
        this.color = color;
        this.fontSize = fontSize;
        this.life = lifetime;
        this.maxLife = lifetime;
        this.speedY = -1;
        this.markedForDeletion = false;
    }
    update() {
        this.y += this.speedY;
        this.life--;
        if (this.life <= 0) this.markedForDeletion = true;
    }
    draw() {
        ctx.save();
        const opacity = this.life / this.maxLife;
        ctx.globalAlpha = opacity;
        
        ctx.fillStyle = this.color;
        ctx.font = `bold ${this.fontSize} 'Orbitron'`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "rgba(0,0,0,0.9)";
        ctx.shadowBlur = 6;
        
        // 외곽선 (더 선명하게)
        ctx.strokeStyle = "rgba(0,0,0,0.8)";
        ctx.lineWidth = 3;
        ctx.strokeText(this.text, this.x, this.y);
        
        ctx.fillText(this.text, this.x, this.y);
        ctx.restore();
    }
}

/**
 * 게임 로직
 */

let player;
let bullets = [];
let zombies = [];
let gates = [];
let particles = [];
let floatingTexts = []; 
let stimpacks = []; // 스팀팩 아이템 배열
let weaponItems = []; // 무기 아이템 배열

let spawnTimer = 0;
let bossMode = false;
let nextStimpackFrame = 0; // 다음 스팀팩 스폰 프레임
let firstBossEncountered = false; // 첫 보스 조우 여부
let nextWeaponItemFrame = 0; // 무기 아이템 스폰 프레임
let firstSpawnDone = false; // 첫 스폰이 숫자벽인지 여부

let normalZombieKillCount = 0;
let normalZombieSpawnCount = 1;
let bulletGroupIdCounter = 0;
let bulletGroupGateHit = {}; 
let zombieSpawnedCount = 0;
let gateIdCounter = 0;

function initGame() {
    player = new Player();
    bullets = [];
    zombies = [];
    gates = [];
    particles = [];
    floatingTexts = [];
    stimpacks = [];
    weaponItems = [];
    
    score = 0;
    waveCount = 1; // 1부터 시작
    bossMode = false;
    distance = 0;
    spawnTimer = 0;
    frameCount = 0;

    normalZombieKillCount = 0;
    normalZombieSpawnCount = 1;
    bulletGroupIdCounter = 0;
    bulletGroupGateHit = {};
    zombieSpawnedCount = 0;
    gateIdCounter = 0;
    
    // 스팀팩 타이머 초기화 (첫 보스 이후 시작)
    nextStimpackFrame = Infinity;
    firstBossEncountered = false;

    // 무기 아이템 타이머 (게임 시작 30초 후 첫 등장)
    nextWeaponItemFrame = 30 * FPS;

    // 첫 스폰은 반드시 숫자벽
    firstSpawnDone = false;

    scoreEl.innerText = score;
    squadEl.innerText = 1;
    buffIndicator.style.display = 'none';
    
    gameState = 'PLAYING';
    menuScreen.classList.add('hidden');
    animate();
}

function createParticles(x, y, color) {
    for (let i = 0; i < 5; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function createFloatingText(text, x, y, color, fontSize, lifetime) {
    floatingTexts.push(new FloatingText(text, x, y, color, fontSize, lifetime));
}

function addSquad(amount) {
    player.squadSize += amount;
    squadEl.innerText = Math.floor(player.squadSize);
    
    squadEl.style.transform = "scale(1.5)";
    squadEl.style.color = "#00ff88";
    squadEl.style.textShadow = "0 0 15px rgba(0, 255, 136, 0.8)";
    setTimeout(() => {
        squadEl.style.transform = "scale(1)";
        squadEl.style.color = "#00d4ff";
        squadEl.style.textShadow = "0 0 6px rgba(0, 212, 255, 0.6)";
    }, 200);
}

function spawnWeaponItem() {
    const type = Math.random() < 0.5 ? 'shotgun' : 'shuriken';
    weaponItems.push(new WeaponItem(type));
}

function spawnEnemies() {
    spawnTimer++;
    
    let spawnRate = 120; 

    if (spawnTimer > spawnRate) {
        spawnTimer = 0;
        waveCount++;

        // 게임 시작 후 첫 번째 스폰은 반드시 숫자벽
        if (!firstSpawnDone) {
            gates.push(new Gate());
            firstSpawnDone = true;
            return;
        }

        if (!bossMode && waveCount % 12 === 0) {
            bossMode = true;
            zombies.push(new ZombieHorde(true)); 
            
            // 보스 등장 4초 후 스팀팩 강제 1회 등장 예약
            nextStimpackFrame = frameCount + 4 * FPS;
            firstBossEncountered = true;
            
            const warning = document.createElement('div');
            warning.innerText = "BOSS APPROACHING";
            warning.style.position = "absolute";
            warning.style.top = "20%";
            warning.style.width = "100%";
            warning.style.textAlign = "center";
            warning.style.color = "#ff4444";
            warning.style.fontSize = "44px";
            warning.style.fontWeight = "900";
            warning.style.fontFamily = "Orbitron";
            warning.style.textShadow = 
                "0 0 20px rgba(255, 68, 68, 0.8), " +
                "0 0 40px rgba(255, 68, 68, 0.5), " +
                "0 4px 8px rgba(0,0,0,0.9)";
            warning.style.letterSpacing = "4px";
            warning.style.zIndex = "5";
            document.body.appendChild(warning);
            setTimeout(() => warning.remove(), 2500);
        } else {
            const rand = Math.random();
            if (rand < 0.6) {
                for (let i = 0; i < normalZombieSpawnCount; i++) {
                    zombies.push(new ZombieHorde(false));
                }
            } else if (rand < 0.8) {
                gates.push(new Gate());
            } else {
                gates.push(new Gate());
                setTimeout(() => {
                    for (let i = 0; i < normalZombieSpawnCount; i++) {
                        zombies.push(new ZombieHorde(false));
                    }
                }, 600);
            }
        }
    }
    
    if (bossMode) {
        const bossExists = zombies.some(z => z.isBoss);
        if (!bossExists) {
            bossMode = false;
        }
    }
}

function update() {
    if (gameState !== 'PLAYING') return;

    frameCount++;
    distance += 5;
    player.update();

    // 스팀팩 스폰 체크
    if (frameCount >= nextStimpackFrame && stimpacks.length === 0 && firstBossEncountered) {
        stimpacks.push(new Stimpack());
        nextStimpackFrame = Infinity; // 아이템 사라지면 다시 세팅
    }

    // 무기 아이템 스폰 체크 (30초 간격, 1개씩)
    if (frameCount >= nextWeaponItemFrame && weaponItems.length === 0) {
        spawnWeaponItem();
        scheduleNextWeaponItem();
    }

    bullets.forEach((bullet) => {
        bullet.update();
        
        let hitZombie = false;

        for (let zombie of zombies) {
            if (zombie.markedForDeletion) continue;
            const dist = Math.hypot(bullet.x - zombie.x, bullet.y - zombie.y);
            if (dist < zombie.radius + 10) {
                hitZombie = true;

                // 표창 관통 데미지 계산
                let appliedDamage = bullet.damage;
                if (bullet.weaponType === 'shuriken') {
                    if (bullet.hitCount === 0) {
                        appliedDamage = bullet.damage;          // 1번째: 100%
                    } else if (bullet.hitCount === 1) {
                        appliedDamage = bullet.damage * 0.5;   // 2번째: 50%
                    } else if (bullet.hitCount === 2) {
                        appliedDamage = bullet.damage * 0.3;   // 3번째: 30%
                    } else {
                        appliedDamage = 0;
                    }
                }

                if (appliedDamage > 0) {
                    const isDead = zombie.takeDamage(appliedDamage);
                    createFloatingText(`-${Math.floor(appliedDamage)}`, bullet.x, bullet.y, '#f1c40f', '20px', 20);
                    createParticles(bullet.x, bullet.y - 10, '#c0392b');

                    if (isDead) {
                        if (!zombie.isBoss) {
                            normalZombieKillCount++;
                            normalZombieSpawnCount = Math.min(30, 1 + Math.floor(normalZombieKillCount / 50));
                        }

                        const gain = Math.floor(zombie.maxHp / 2);
                        score += gain;
                        scoreEl.innerText = score;
                        createFloatingText(`+${gain}점`, zombie.x, zombie.y, '#f1c40f', '24px', 40); 
                    }
                }

                bullet.hitCount++;

                // 표창이 아니거나, 표창이라도 3명 맞추면 소멸
                if (bullet.weaponType !== 'shuriken' || bullet.hitCount >= 3) {
                    bullet.markedForDeletion = true;
                    break; // 일반 총알이거나 표창이 3명 맞추면 종료
                }
                
                // 표창이 3명 미만 맞췄으면 관통하여 다음 좀비도 확인 (break하지 않음)
                // 일반 총알은 한 좀비만 처리하므로 break
                if (bullet.weaponType !== 'shuriken') {
                    break;
                }
            }
        }

        if (!hitZombie) {
            for (let gate of gates) {
                if (bullet.y < gate.y + gate.height && bullet.y > gate.y &&
                    bullet.x > gate.x && bullet.x < gate.x + gate.width) {
                    
                    createParticles(bullet.x, bullet.y, '#fff');

                    const key = `${bullet.groupId}-${gate.id}`;
                    if (!bulletGroupGateHit[key]) {
                        bulletGroupGateHit[key] = true;
                        gate.hit(); // 같은 탄막이라도 다른 숫자벽은 각각 증가
                    }
                    break;
                }
            }
        }
    });

    zombies.forEach(z => z.update());
    gates.forEach(g => g.update());
    stimpacks.forEach(s => s.update());
    weaponItems.forEach(w => w.update());
    particles.forEach(p => p.update());
    floatingTexts.forEach(t => t.update());

    bullets = bullets.filter(b => !b.markedForDeletion);
    zombies = zombies.filter(z => !z.markedForDeletion);
    gates = gates.filter(g => !g.markedForDeletion);
    stimpacks = stimpacks.filter(s => !s.markedForDeletion);
    weaponItems = weaponItems.filter(w => !w.markedForDeletion);
    particles = particles.filter(p => p.life > 0);
    floatingTexts = floatingTexts.filter(t => !t.markedForDeletion);

    spawnEnemies();
}

function drawBackground() {
    // 전장 배경 - 어둡고 현실적인 느낌
    const gradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
    gradient.addColorStop(0, "#1a1a1a");
    gradient.addColorStop(0.3, "#0f0f0f");
    gradient.addColorStop(0.7, "#0a0a0a");
    gradient.addColorStop(1, "#050505");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    
    // 먼지와 잔해 효과
    if (Math.random() < 0.3) {
        ctx.fillStyle = "rgba(80, 60, 40, 0.15)";
        const dustX = Math.random() * canvasWidth;
        const dustY = Math.random() * canvasHeight;
        const dustSize = Math.random() * 3 + 1;
        ctx.beginPath();
        ctx.arc(dustX, dustY, dustSize, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // 조명 효과 (스포트라이트 같은)
    const lightGradient = ctx.createRadialGradient(
        canvasWidth / 2, canvasHeight * 0.3, 0,
        canvasWidth / 2, canvasHeight * 0.3, canvasHeight * 0.6
    );
    lightGradient.addColorStop(0, "rgba(100, 80, 60, 0.1)");
    lightGradient.addColorStop(0.5, "rgba(50, 40, 30, 0.05)");
    lightGradient.addColorStop(1, "rgba(0, 0, 0, 0)");
    ctx.fillStyle = lightGradient;
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    
    // 전장 구분선 (더 현실적인 스타일)
    ctx.strokeStyle = "rgba(100, 80, 60, 0.2)";
    ctx.lineWidth = 2;
    ctx.setLineDash([40, 20, 10, 20]);
    ctx.lineDashOffset = -distance * 0.5; 
    
    // 중앙 구분선
    ctx.beginPath();
    ctx.moveTo(canvasWidth/2, 0);
    ctx.lineTo(canvasWidth/2, canvasHeight);
    ctx.stroke();
    
    // 측면 가이드 라인
    ctx.strokeStyle = "rgba(80, 60, 40, 0.15)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(canvasWidth * 0.25, 0);
    ctx.lineTo(canvasWidth * 0.25, canvasHeight);
    ctx.moveTo(canvasWidth * 0.75, 0);
    ctx.lineTo(canvasWidth * 0.75, canvasHeight);
    ctx.stroke();
    
    ctx.setLineDash([]);
    
    // 지면 텍스처 (바닥 느낌)
    ctx.fillStyle = "rgba(40, 30, 20, 0.3)";
    ctx.fillRect(0, canvasHeight - 20, canvasWidth, 20);
    
    // 전장 분위기 (연기 효과)
    if (Math.random() < 0.1) {
        ctx.fillStyle = "rgba(50, 50, 50, 0.2)";
        const smokeX = Math.random() * canvasWidth;
        const smokeY = canvasHeight - 30 + Math.sin(Date.now() * 0.001) * 10;
        ctx.beginPath();
        ctx.arc(smokeX, smokeY, 8, 0, Math.PI * 2);
        ctx.arc(smokeX + 5, smokeY - 3, 6, 0, Math.PI * 2);
        ctx.fill();
    }
}

function draw() {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    
    drawBackground();
    
    gates.forEach(g => g.draw()); 
    stimpacks.forEach(s => s.draw());
    weaponItems.forEach(w => w.draw());
    zombies.forEach(z => z.draw());
    bullets.forEach(b => b.draw());
    particles.forEach(p => p.draw());
    player.draw();
    floatingTexts.forEach(t => t.draw()); 
}

function animate() {
    if (gameState !== 'PLAYING') return;
    
    update();
    draw();
    frameId = requestAnimationFrame(animate);
}

function gameOver() {
    gameState = 'GAMEOVER';
    cancelAnimationFrame(frameId);
    
    menuScreen.classList.remove('hidden');
    document.querySelector('.title').innerText = "MISSION FAILED";
    menuSubtitle.innerHTML = `최종 점수: <span style="color:#f1c40f">${score}</span><br>최대 병력: ${Math.floor(player.squadSize)}`;
    startBtn.innerText = "다시 도전";
}

startBtn.addEventListener('click', () => {
    initGame();
});

</script>
</body>
</html>
